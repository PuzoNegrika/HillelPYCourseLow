# Замикання.
# !!! Замикання - це концепція, яка виникає, коли функція визначається всередині іншої функції і отримує доступ до змінних з оточення (лексичного контексту), в якому вона була визначена
# У Python це створює замкнуту область видимості для функцій, що дозволяє їм зберігати стан і взаємодіяти з змінними навколишнього контексту
#
# Основні Компоненти Замикань:  !!!
# 1. Зовнішня Функція (Outer Function): Це функція, в якій визначається внутрішня функція. Вона створює та повертає внутрішню функцію
# 2. Внутрішня Функція (Inner Function): Це функція, визначена всередині зовнішньої функції. Вона отримує доступ до змінних з оточення зовнішньої функції

# Приклад Замикання:
# !!! Замикання - це концепція, при якій функція зберігає оточення, в якому вона була створена
# Це дозволяє функції отримувати доступ до змінних та інших ресурсів з контексту, в якому вони були визначені
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(10)
result = closure(5)
print(result)  # Вивід: 15
# У цьому прикладі outer_function приймає аргумент x і визначає inner_function, яка має доступ до x
# Коли ми викликаємо outer_function(10), вона повертає inner_function, і closure тепер стає функцією, яка може використовувати значення x
# При виклику closure(5), функція inner_function отримує доступ до значення x (що дорівнює 10) та виконує операцію x + y, в результаті чого отримуємо 15

# Використання Замикань:  !!!
# 1. Інкапсуляція та Захист Даних: Замикання дозволяють зберігати дані приватними для зовнішньої функції, обмежуючи доступ до них лише через внутрішню функцію
# 2. Створення Фабрик Об'єктів: Замикання можуть бути використані для створення функцій, які генерують та повертають інші функції з параметрами за замовчуванням
# 3. Керування Специфічним Станом: Замикання можуть зберігати стан і використовувати його при виклику внутрішніх функцій

def counter(start):
    count = start
    def increment():
        nonlocal count  # Для доступу до локальної змінної внутрішньої функції (дає доступ, щоб ії поміняти)
        count += 1
        return count
    return increment

counter1 = counter(0)
print(counter1())  # Вивід: 1
print(counter1())  # Вивід: 2
print(counter1())  # Вивід: 3
counter1 = counter(1)
print(counter1())  # Вивід: 2
print(counter1())  # Вивід: 3
print(counter1())  # Вивід: 4
print()
# nonlocal - це ключове слово в Python, яке використовується у вкладених функціях, щоб вказати, що змінна належить не до локальної, а до зовнішньої (охоплюючої) області видимості, а не до глобальної
# У цьому прикладі замикання counter використовує внутрішню функцію increment, щоб збільшувати значення лічильника замикання
# Замикання є потужним інструментом для створення ефективного, модульного та гнучкого коду в Python
# Вони дозволяють створювати функції, які можуть взаємодіяти зі своїм оточенням, що вирішує конкретні завдання та забезпечує високий рівень інкапсуляції


# Декоратор без Аргументів.
# !!! Декоратор - це функція в Python, яка приймає іншу функцію та розширює її функціонал або змінює поведінку
# Використовуючи декоратори, можна легко та зручно модифікувати чи розширювати функціонал існуючих функцій без зміни їхнього вихідного коду
# Декоратори використовуються для покращення читабельності коду та забезпечення його перевикористання

# Приклад Декоратора без Аргументів:
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

# Виклик функції з декоратором
say_hello()
# Вивід: Something is happening before the function is called.
       # Hello!
       # Something is happening after the function is called.
print()
# У цьому прикладі my_decorator - це декоратор, який приймає функцію func та повертає нову функцію wrapper
# Функція wrapper додає додатковий функціонал до вхідної функції say_hello
# При виклику say_hello() насправді викликається wrapper, яка виводить повідомлення до та після виклику оригінальної функції say_hello

# Використання Декоратора без Аргументів:
# 1. Логування та Аудит: Декоратори можуть використовуватися для логування подій або проведення аудиту в коді, додаючи логічність до функцій
# 2. Кешування Результатів: Декоратори можуть кешувати результати функцій, щоб уникнути повторних обчислень у випадках, коли вони є витратними
# 3. Вимірювання Часу Виконання: Декоратори можуть вимірювати час виконання функцій для оптимізації та виявлення ділянок коду, які потребують оптимізації
# Декоратори без аргументів дозволяють додавати здатність до функцій без передачі додаткових параметрів
# Вони є потужним інструментом для вдосконалення та адаптації існуючого коду, зробивши його більш гнучким та перевикористовуваним


# Декоратор із Аргументами.
# !!! Декоратори можуть бути розширені для приймання аргументів, щоб надавати більшу гнучкість та конфігурацію
# Це досягається додаванням ще одного рівня вкладеності функцій. Декоратор із аргументами приймає параметри під час визначення, що дозволяє налаштовувати його поведінку

# Приклад Декоратора із Аргументами:
def decorator_with_args(prefix):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"{prefix}: Something is happening before the function is called.")
            result = func(*args, **kwargs)
            print(f"{prefix}: Something is happening after the function is called.")
            return result
        return wrapper
    return decorator

@decorator_with_args("LOG") # в префікс іде "LOG"
def say_hello():
    print("Hello!")

# Виклик функції з декоратором із аргументами
say_hello()
# Вивід: LOG: Something is happening before the function is called.
       # Hello!
       # LOG: Something is happening after the function is called.
# У цьому прикладі decorator_with_args - це функція, яка приймає аргумент prefix та повертає декоратор decorator
# Декоратор decorator приймає функцію func та повертає нову функцію wrapper. Функція wrapper виводить повідомлення з префіксом перед та після виклику оригінальної функції

# Використання Декоратора із Аргументами:
# Конфігурування Декораторів: Декоратори із аргументами дозволяють конфігурувати їхню поведінку під час визначення. Наприклад, у прикладі вище аргумент "LOG" визначає префікс для логування
# Застосування Різних Декораторів: Ви можете використовувати одну функцію як декоратор із різними конфігураціями для різних функцій
@decorator_with_args("INFO")
def greet():
    print("Greetings!")

@decorator_with_args("DEBUG")
def farewell():
    print("Farewell!")

print()
# Логування та Моніторинг: Декоратори із аргументами можуть бути використані для додавання логування, моніторингу або аудиту для різних функцій
# Декоратори із аргументами додають рівень гнучкості та можливості налаштування до декораторів, роблячи їх більш універсальними для різних сценаріїв використання


# Загальні Корисні Властивості та Рекомендації.
# Зберігайте Сигнатуру Функції: Декоратори можуть використовуватися для зміни функції, але зазвичай доречно зберігати сигнатуру оригінальної функції. Для цього можна використовувати args та *kwargs у внутрішній функції
# Декорування Класів: Декоратори можуть також використовуватися для декорування методів класів, роблячи їх статичними або класовими методами
# Комбінація Декораторів: Ви можете комбінувати кілька декораторів для однієї функції, що дозволяє вам гнучко розширювати її функціонал

# Декоратори в Python - потужний інструмент для модифікації функцій та методів класів
# Однак для забезпечення чистоти та читабельності коду існують загальні корисні властивості та рекомендації:

# 1 - Зберігайте Сигнатуру Функції:
# Зберігайте оригінальну сигнатуру функції, щоб уникнути непорозумінь і забезпечити сумісність з іншими частинами коду
# Використовуйте *args та **kwargs у внутрішніх функціях, щоб приймати будь-яку кількість позиційних та іменованих аргументів
def my_decorator(func):
    def wrapper(*args, **kwargs):
        # Ваш код декоратора
        result = func(*args, **kwargs)
        # Додаткові дії після виклику оригінальної функції
        return result
    return wrapper

# 2 - Декорування Класів:
# Декоратори можна використовувати для декорування методів класів.
# Для цього використовуйте декоратор як метод класу або створіть декоратор, який приймає клас та повертає його, можливо, з модифікованим функціоналом
def class_decorator(cls):
    class DecoratedClass(cls):
        def new_method(self):
            print("New method added by the decorator")
    return DecoratedClass

@class_decorator
class MyClass:      # MyClass вже не оригінальний клас, а DecoratedClass, який наслідує оригінальний і має додатковий метод new_method
    def existing_method(self):
        print("Existing method in the original class")

# Виклик методів
obj = MyClass()
obj.existing_method()   # Викликає метод оригінального класу: (Existing method in the original class)
obj.new_method()    # Викликає новий метод, доданий декоратором: (New method added by the decorator)

# 3 - Комбінація Декораторів:
# Ви можете комбінувати кілька декораторів для однієї функції, використовуючи їх послідовно
# @decorator1
# @decorator2
def my_function():
    # Код функції
    pass
print()
# Порядок важливий: спочатку виконається decorator1, а потім decorator2. Це дозволяє гнучко розширювати функціонал функції
# Декоратори і замикання роблять код більш зрозумілим, гнучким і дозволяють реюзати та розширювати функціонал вашого коду
# Використовуйте їх розумно, дотримуючись зазначених вище рекомендацій для забезпечення ефективної роботи та збереження чистоти коду