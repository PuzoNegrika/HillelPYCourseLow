# Оцінка складності алгоритмів.
# !!! Оцінка складності алгоритмів - це процес визначення, наскільки ефективно та швидко працює алгоритм при збільшенні обсягу вхідних даних
# Оцінка складності включає в себе два аспекти:
#
# Часова складність:
# Часова складність алгоритму визначає, як змінюється час виконання програми при збільшенні розміру вхідних даних
# Оцінка часової складності може бути виконана за допомогою "O-нотації" (нотація О-велике):
# 1. O(1) - константний час: Алгоритм виконується за постійний час, незалежно від обсягу вхідних даних
# 2. O(log n) - логарифмічний час: Час виконання зменшується логарифмічно при збільшенні розміру вхідних даних. Характерний для ефективних алгоритмів пошуку, таких як бінарний пошук
# 3. O(n) - лінійний час: Час виконання пропорційний розміру вхідних даних. Наприклад, лінійний пошук
# 4. O(n log n) - n логарифмічний час: Характерно для багатьох ефективних алгоритмів сортування, таких як швидке сортування чи злиття
# 5. O(n^2) - квадратичний час: Час виконання пропорційний квадрату розміру вхідних даних. Часто зустрічається у простих алгоритмах сортування, таких як сортування бульбашкою
# 6. O(2^n) - експоненціальний час: Час виконання росте експоненційно при збільшенні розміру вхідних даних. Характерно для деяких алгоритмів рекурсивного пошуку

# Просторова складність
# Просторова складність визначає, як змінюється обсяг пам'яті, який використовується алгоритмом, в залежності від розміру вхідних даних
# 1. O(1) - константний простір: Алгоритм використовує постійний обсяг пам'яті, незалежно від розміру вхідних даних
# 2. O(n) - лінійний простір: Обсяг пам'яті пропорційний розміру вхідних даних
# 3. O(n^2) - квадратичний простір: Обсяг пам'яті пропорційний квадрату розміру вхідних даних

# Враховуючи обидві складності, можна зробити обгрунтовані вибори алгоритмів для конкретних завдань та вхідних даних
# Розуміння оцінки складності допомагає у створенні ефективних та швидких програм, що можуть обробляти великі обсяги даних з мінімальними ресурсами.


# Алгоритм сортування бульбашкою.
# Алгоритм сортування бульбашкою є одним із простих методів сортування
# Він базується на послідовному порівнянні та обміні сусідніх елементів, доки весь масив не буде відсортований
#
# Опис алгоритму:
# 1. Порівняння та обмін. Починаючи з початку масиву, порівнюються пари сусідніх елементів. Якщо елементи не знаходяться в правильному порядку, вони обмінюються
# 2. Проходження по масиву. Після першого проходу найбільший елемент встане на своє місце в кінці масиву. Аналогічно проводяться наступні проходи, але вже без урахування останніх елементів (оскільки вони вже відсортовані)
# 3. Повторення. Процес повторюється, доки весь масив не буде відсортований
#
# Реалізація на прикладі:
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# Приклад використання
my_list = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(my_list)
print("Відсортований масив:", my_list) # [11, 12, 22, 25, 34, 64, 90]
print()
# Аналіз складності:
# 1. Часова складність: O(n^2) - квадратичний час. Для кожного елемента потрібно провести n порівнянь на кожному проході
# 2. Просторова складність: O(1) - константний простір. Додаткової пам'яті, окрім пам'яті для самого масиву, не потрібно
# Алгоритм сортування бульбашкою використовується для навчання та розуміння базових концепцій сортування, але в реальних застосунках вважається неефективним на великих об'ємах даних


# Алгоритм лінійного пошуку.
# !!! Алгоритм лінійного пошуку - це простий метод пошуку, при якому елементи послідовно перевіряються до того моменту,
# поки не буде знайдено шуканий елемент або не буде перевірено всі елементи колекції
#
# Опис алгоритму:
# 1. Послідовне перевіряння. Алгоритм розпочинається з перевірки першого елемента колекції, потім другого, третього і так далі, до тих пір, поки не буде знайдено шуканий елемент або не буде пройдено всю колекцію
# 2. Повернення результату. Якщо знайдений шуканий елемент, повертається його індекс (або сам елемент). Якщо елемент не знайдено, повертається спеціальне значення (часто -1 або None), що вказує на те, що елемент відсутній в колекції
#
# Реалізація на прикладі:
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Повертає індекс знайденого елемента
    return -1  # Повертає -1, якщо елемент не знайдено

# Приклад використання
my_list = [64, 34, 25, 12, 22, 11, 90]
result = linear_search(my_list, 22)
print("Індекс шуканого елемента:", result) # 4
print()
# Аналіз складності:
# 1. Часова складність: O(n) - лінійний час. Кількість операцій зростає лінійно з розміром колекції
# 2. Просторова складність: O(1) - константний простір. Додаткової пам'яті, що залежить від розміру колекції, не потрібно
# Алгоритм лінійного пошуку ефективний для невеликих об'ємів даних, але не є оптимальним для великих колекцій


# Бінарний пошук.
# !!! Бінарний пошук - це швидкий алгоритм пошуку, що використовується для знаходження елемента в відсортованому масиві
# !!! Принцип роботи полягає в послідовному поділі масиву навпіл та порівнянні значення шуканого елемента з серединою масиву
#
# Опис алгоритму:
# 1. Визначення меж пошуку. Визначаються дві межі: low (нижня межа) та high (верхня межа), які вказують на діапазон масиву, де відбуватиметься пошук
# 2. Порівняння з серединою. Знаходиться середина поточного діапазону: mid = (low + high) // 2. Порівнюється значення елемента arr[mid] з шуканим значенням
# 3. Зменшення діапазону. Якщо значення в середині менше шуканого, то діапазон зміщується вправо, встановлюючи low = mid + 1. Якщо більше, то діапазон зміщується вліво, встановлюючи high = mid - 1
# 4. Повторення. Кроки 2-3 повторюються, доки не буде знайдено шуканий елемент або діапазон зменшиться до нуля
# 5. Повернення результату. Якщо елемент знайдено, повертається його індекс. Якщо діапазон зменшиться до нуля, а елемент не буде знайдено, повертається -1
#
# Реалізація на прикладі:
def binary_search(arr, target):
    low, high = 0, len(arr) - 1     # len(arr) = 7, 7 - 1 = 6. high = 6

    while low <= high:      # 0 <= 6
        mid = (low + high) // 2      # 6 // 2 = 3. mid = 3
        if arr[mid] == target:
            return mid  # Повертає індекс знайденого елемента
        elif arr[mid] < target:     # так, бо arr[mid] = 3, і воно < target, коли target у нас 22
            low = mid + 1       # mid = 3 + 1. mid = 4
        else:
            high = mid - 1

    return -1  # Повертає -1, якщо елемент не знайдено

# Приклад використання
my_list = [11, 12, 22, 25, 34, 64, 90]
result = binary_search(my_list, 22)
print("Індекс шуканого елемента:", result) # 4, візьмемо 12.
print()
# Аналіз складності:
# 1. Часова складність: O(log n) - логарифмічний час. Кожна ітерація зменшує діапазон пошуку вдвічі
# 2. Просторова складність: O(1) - константний простір. Додаткової пам'яті, що залежить від розміру вхідного масиву, не потрібно
# Бінарний пошук є ефективним алгоритмом для знаходження елемента в відсортованому масиві
# Його логарифмічна часова складність робить його одним з найшвидших методів пошуку
# Використовуючи принцип "поділ і завоювання", бінарний пошук дозволяє ефективно скорочувати діапазон пошуку до того часу, поки не буде знайдений шуканий елемент
# Завдяки своїй ефективності використання і простоті реалізації, бінарний пошук широко використовується у великій кількості застосувань, де необхідно ефективно шукати дані в відсортованих масивах


# Візуалізація деяких видів сортувань.
# !!! Візуалізація сортувань - це потужний інструмент для навчання, розуміння та аналізу алгоритмів сортування в динаміці
# !!! Використовуючи бібліотеку matplotlib у Python, можна створити анімації, які ілюструють кроки сортування та зміни, що відбуваються з елементами масиву
#
# Наприклад, розглянемо візуалізацію сортування бульбашкою
# У цьому алгоритмі пари сусідніх елементів порівнюються і обмінюються, якщо вони не знаходяться в правильному порядку
# Цей процес повторюється до тих пір, поки масив не буде відсортований:
import matplotlib.pyplot as plt
import matplotlib.animation as animation


def bubble_sort_visualization(data):
    """
    Візуалізація сортування бульбашкою.

    :param data: Початкові дані для сортування та візуалізації.
    """
    n = len(data)

    fig, ax = plt.subplots()
    bars = ax.bar(range(n), data, align='edge')

    def update(frame):
        for i in range(n - frame - 1):
            if data[i] > data[i + 1]:
                data[i], data[i + 1] = data[i + 1], data[i]

        for bar, h in zip(bars, data):
            bar.set_height(h)

    ani = animation.FuncAnimation(fig, update, frames=n - 1, repeat=False)
    plt.show()


# Приклад використання
initial_data = [64, 34, 25, 12, 22, 11, 90]
bubble_sort_visualization(initial_data)
print()
# Використовуючи анімацію, можна спостерігати, як кожна ітерація алгоритму впливає на розташування елементів масиву
# Така візуалізація створює зрозуміле та інтуїтивно зрозуміле зображення процесу сортування, допомагаючи краще зрозуміти його роботу та ефективність


# Поняття файлу.
# Файли в програмуванні є важливою складовою для роботи з даними
# Термін "файл" вказує на структурований набір даних, які можна зберігати на постійних носіях, таких як жорсткий диск, SSD, флеш-накопичувач чи інші
# Вони використовуються для різних завдань, таких як збереження, обмін та обробка інформації
#
# Типи файлів:
# Текстові файли:
# 1. Зберігають символьні дані у формі тексту
# 2. Зчитуються та редагуються зручним для користувача способом
# 3. Можуть містити рядки, числа, символи та інші символьні дані
#
# Бінарні файли:
# 1. Зберігають дані у бінарному форматі, який не є текстовим
# 2. Використовуються для збереження зображень, аудіо, відео та інших не-текстових даних
# 3. Редагуються за допомогою спеціалізованих програм або коду


# Робота з файлами.
# !!! У Python робота з файлами здійснюється за допомогою вбудованих функцій та об'єктів
# !!! Основні операції з файлами включають відкриття файлу, читання з файлу, запис в файл та закриття файлу
#
# Відкриття файлу:
# Для відкриття файлу використовується функція open()
# Ця функція повертає об'єкт файлу, який можна використовувати для подальших операцій:
##   file = open("example.txt", "r")  # Відкриття файлу для читання
# Де параметр "r" вказує, що файл відкривається для читання
# Інші можливі значення цього параметру: "w" (запис), "a" (дописування), "b" (бінарний режим) та інші
#
# Читання з файлу:
# Для читання даних з файлу використовується метод read() або readline():
##   content = file.read()  # Читання всього вмісту файлу
##   line = file.readline()  # Читання одного рядка з файлу
#
# Запис в файл:
# Для запису даних у файл використовується метод write():
##  file.write("Hello, World!")  # Запис рядка у файл
#
# Закриття файлу:
# Після завершення роботи з файлом його слід закрити за допомогою методу close()
##  file.close()  # Закриття файлу

# Робота з файлами є важливою частиною розробки програм та обробки даних в Python
# Використання менеджера контексту (за допомогою конструкції with) рекомендується для автоматичного закриття файлу після завершення його використання, що покращує безпеку та ефективність коду


# Менеджер контексту.
# В Python, для забезпечення коректного використання ресурсів, таких як файли, та автоматичного їхнього закриття,
# рекомендується використовувати конструкцію "менеджера контексту" з ключовим словом with
# Це забезпечує безпечне та ефективне використання ресурсів навіть у випадку виникнення винятку
#
# Використання "менеджера контексту" з файлами:
##  with open("example.txt", "r") as file:
    ##  content = file.read()
    # Робота з файлом у межах блоку "with"

# Автоматичне закриття файлу поза блоком "with"
# У цьому прикладі, файл example.txt відкривається для читання у блоку with
# Після виходу з блоку, навіть якщо виникне виняток, файл буде автоматично закритий
# Такий підхід робить код безпечнішим та зменшує ймовірність витоку ресурсів

# Важливою перевагою "менеджера контексту" є його універсальність
# Цей підхід може бути використаний не лише для роботи з файлами, але й для інших ресурсів, таких як мережеві з'єднання чи бази даних

# Користуючись "менеджером контексту" у роботі з файлами, розробник може значно полегшити управління ресурсами та забезпечити правильне їхнє використання у програмі


# ООП та його принципи.
# !!! Об'єктно-орієнтоване програмування (ООП) - це парадигма програмування, яка базується на використанні об'єктів, які можуть взаємодіяти один з одним
# !!! Основні принципи ООП допомагають в розробці більш структурованих, гнучких та підтримуваних програм
# (є картинка в папці)


# Поліморфізм.
# !!! Поліморфізм - це один з основних принципів об'єктно-орієнтованого програмування (ООП), який дозволяє використовувати однаковий інтерфейс для об'єктів різних класів
# Це спрощує код і робить його більш гнучким та легким для розширення
#
# Розглянемо більш детально, як працює поліморфізм на прикладі мови програмування Python:
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

def animal_sound(animal):
    return animal.speak()

dog_instance = Dog()
cat_instance = Cat()

print(animal_sound(dog_instance))  # Вивід: Woof!
print(animal_sound(cat_instance))  # Вивід: Meow!

# Поліморфізм за допомогою Методів
# У даному випадку, об'єкти dog_instance та cat_instance належать різним класам, але обидва класи мають метод з іменем speak
# Функція animal_sound приймає будь-який об'єкт, який має метод speak, і викликає цей метод
# Оскільки обидва класи мають метод speak, ми можемо передавати об'єкти обох класів у функцію, і вона буде працювати коректно

# Поліморфізм за допомогою Операторів
# Поліморфізм може також застосовуватися до операторів. Наприклад, операція + може мати різні реалізації залежно від типів операндів
result = 5 + 10  # Використано для чисел
result_str = "Hello, " + "World!"  # Використано для рядків
print()
# Тут операція + має різні реалізації для чисел та рядків, і це також є прикладом поліморфізму

# Переваги Поліморфізму: !!!
# 1. Універсальність: Дозволяє використовувати один і той самий код для обробки об'єктів різних класів
# 2. Легше Розширення: Нові класи можуть легко додавати функціональність, не змінюючи існуючий код
# 3. Читабельність Коду: Робить код більш зрозумілим та читабельним
# Поліморфізм грає ключову роль в розвитку об'єктно-орієнтованих систем, надаючи їм гнучкість та простоту в управлінні


# Інкапсуляція.
# !!! Інкапсуляція є одним із принципів об'єктно-орієнтованого програмування (ООП), який означає обмеження доступу до певних елементів класу та збереження його стану
# !!! Цей принцип визначає, що внутрішня реалізація об'єкта (його поля та методи) повинна бути прихована від зовнішнього світу
#
# Розглянемо детальніше, як працює інкапсуляція на прикладі мови програмування Python:
class Car:
    def __init__(self):
        self.__speed = 0  # Приватний атрибут

    def accelerate(self):
        self.__speed += 10

    def get_speed(self):
        return self.__speed

my_car = Car()
my_car.accelerate()
print(my_car.get_speed())  # Вивід: 10
# print(my_car.__speed)  # Помилка: 'Car' object has no attribute '__speed'

# Приватні Атрибути та Методи
# !!! У класі Car атрибут __speed є приватним, оскільки він починається з подвійного підкреслення. Це означає, що він не може бути звернутий напряму ззовні класу
# Методи accelerate та get_speed використовуються для зміни та отримання значення цього атрибута

# Контроль Доступу
# Використання інкапсуляції дозволяє контролювати доступ до атрибутів та методів класу
# !!! Приватні атрибути та методи можуть бути змінені або викликані тільки всередині самого класу

# Захист від Неправильного Використання
# Приватні атрибути і методи допомагають уникнути неправильного використання класу ззовні
# Вони підтримують принцип "інформаційного приховування", коли деталі реалізації класу заховані від користувача

# Захист від Змін
# !!! Якщо атрибут або метод позначено як приватний, це також захищає від змін в розробці та розширенні класу
# Зовнішній код, що використовує клас, не залежить від внутрішньої реалізації

# Гетери та Сетери
# Метод get_speed у прикладі є прикладом гетера, який дозволяє отримати значення приватного атрибута
# Зазвичай використовуються гетери та сетери для контролю доступу до приватних полів

# Інкапсуляція сприяє безпеці, контролю та ефективності об'єктно-орієнтованих систем, роблячи код більш надійним та зручним для використання


# Успадкування.
# !!! Успадкування (Inheritance) у програмуванні - це механізм, за допомогою якого новий клас (підклас) може успадковувати атрибути та методи іншого класу (базового класу або батьківського класу)
# Цей механізм дозволяє створювати більш загальні класи та використовувати їх для створення більш спеціалізованих класів
#
# Основні поняття та ідеї щодо успадкування:
# 1. Базовий клас (Батьківський клас): Це клас, в якому визначаються атрибути та методи, які можуть бути успадковані:
class Animal:
    def speak(self):
        pass

# 2. Підклас (Дочірній клас): Це клас, який успадковує атрибути та методи базового класу
# !!! Він може розширювати чи перевизначати функціонал базового класу:
class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# 3. Інтерфейс та реалізація: Успадкування дозволяє розділити абстракцію (інтерфейс) та реалізацію (код методів)
# Базовий клас може визначати абстракцію, а підкласи можуть надавати реалізацію

# 4. super() функція: Ця функція використовується для виклику методів базового класу з підкласу
# !!! Вона дозволяє отримати доступ до методів базового класу та розширювати їх:
class Dog(Animal):
    def speak(self):
        base_sound = super().speak()  # Виклик методу базового класу
        return f"{base_sound} Woof!"

# 5. Множинне успадкування: Мови програмування можуть підтримувати як множинне, так і одинарне успадкування
# Множинне успадкування дозволяє класу успадковувати атрибути та методи від кількох класів
# У Python можливе одинарне успадкування, але використання композиції може замінити потребу в множинному успадкуванні:
class Pet:
    def play(self):
        pass

class Dog(Animal, Pet):  # Успадкування від двох класів
    def speak(self):
        return "Woof!"

    def play(self):  # Реалізація методу із іншого базового класу
        return "Fetching the ball!"

# 6. Поліморфізм через успадкування: Поліморфізм означає, що різні класи можуть використовувати один і той самий метод чи атрибут, але представляти його різним чином
# !!! Успадкування дозволяє використовувати поліморфізм, наприклад, при використанні методу speak() у різних класах:
dog_instance = Dog()
cat_instance = Cat()

print(dog_instance.speak())  # Вивід: Woof!
print(cat_instance.speak())  # Вивід: Meow!

# Успадкування є однією з ключових концепцій об'єктно-орієнтованого програмування, яка дозволяє створювати розширювані та багатофункціональні програми
# Використання правильної архітектури успадкування робить програмний код більш читабельним, ефективним та легко змінюваним


# Абстракція.
# !!! Абстракція в об'єктно-орієнтованому програмуванні - це процес приховування складних деталей реалізації та надання простого та зрозумілого інтерфейсу для використання
# Основна ідея полягає в тому, щоб визначити, що об'єкт чи клас повинен робити, але не як саме він це робить

# Основні концепції та засоби реалізації абстракції включають:
# 1. Абстрактні класи:
# Абстрактний клас - це клас, який містить хоча б один абстрактний метод
# Абстрактний метод - це метод, який визначається, але не має конкретної реалізації у самому класі
# Визначення абстрактного класу дозволяє створювати об'єкти лише на основі його підкласів, а не самого класу:
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# В даному прикладі Shape - абстрактний клас з абстрактним методом area
# Підкласи, які успадковують цей клас, повинні надавати конкретну реалізацію методу area

# 2. Інтерфейси:
# Інтерфейс - це абстрактний клас, в якому всі методи є абстрактними
# Відсутність конкретної реалізації методів робить інтерфейси чистими абстракціями:
from abc import ABC, abstractmethod

class Drawable(ABC):
    @abstractmethod
    def draw(self):
        pass

# В даному прикладі Drawable - це інтерфейс з одним абстрактним методом draw. Класи, які реалізують цей інтерфейс, повинні надати конкретну реалізацію методу draw

# 3. Поліморфізм через абстракцію:
# Абстракція дозволяє використовувати поліморфізм, тобто можливість одного і того ж інтерфейсу для об'єктів різних класів
#  Це дозволяє обмінювати об'єкти різних класів, якщо вони реалізують один і той самий абстрактний клас чи інтерфейс
def print_area(shape):
    print(f"Area: {shape.area()}")

circle = Circle(radius=5)
rectangle = Rectangle(width=4, height=6)

print_area(circle)  # Вивід: Area: 78.54
print_area(rectangle)  # Вивід: Area: 24
print()
# У цьому прикладі print_area - це функція, яка очікує об'єкт, який реалізує абстрактний клас Shape
# Таким чином, можна передавати об'єкти різних класів, які успадковують Shape, і використовувати їхні методи

# Абстракція дозволяє створювати більш загальні та повторно використовувані компоненти, зменшує залежність від конкретної реалізації, полегшує розширення та підтримку коду


# Класи та об'єкти.
# 1. Поняття класу та об'єкта:
# Клас в програмуванні є структурою, яка представляє собою шаблон для створення об'єктів
# Клас визначає атрибути (змінні) та методи (функції), які будуть мати його екземпляри, тобто об'єкти
# Класи є засобом реалізації концепції об'єктно-орієнтованого програмування (ООП) в Python
#
# Приклад класу в Python:
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print("Woof!")

# У цьому прикладі ми створюємо клас Dog, який має атрибути name і age, а також метод bark
# Клас слугує шаблоном для створення конкретних екземплярів собак

# 2. Об'єкт - це конкретний екземпляр класу. Він представляє конкретний об'єкт або екземпляр, який має конкретні значення атрибутів, визначені в класі, і може викликати його методи
# Створення об'єкта:
my_dog = Dog(name="Buddy", age=3)
# У цьому прикладі my_dog є об'єктом класу Dog, створеним на основі цього класу. Об'єкт має атрибути name та age, і може викликати методи класу, такі як bark