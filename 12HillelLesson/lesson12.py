# Класи та об'єкти.
# Поняття класу та об'єкта.
# !!! Клас - це конструкція, яка дозволяє створювати об'єкти. Він визначає атрибути (змінні) та методи (функції), які будуть доступні для кожного екземпляра цього класу
# !!! Клас слугує шаблоном або "заготовкою" для об'єктів
# екземпляр класу в Python - це конкретний об’єкт, створений на основі класу, який виступає як шаблон (x = Екземпляр()). Коли ви створюєте екземпляр, ви викликаєте клас, передаючи аргументи, які ініціалізують його початковий стан (за допомогою методу __init__). Це дозволяє створювати кілька незалежних об’єктів, кожен зі своїми власними атрибутами, які описуються у клас
#
# Приклад:
class Car:
    wheels = 4  # атрибут класу

    def __init__(self, make, model):
        # атрибути екземпляра
        self.make = make
        self.model = model

    def start_engine(self):
        return "Engine started!"

print()

# У цьому прикладі клас Car визначає три різні елементи:
# цьому прикладі клас Car визначає три різні елементи:
# 1. wheels: Атрибут класу, який є спільним для всіх об'єктів класу
# 2. __init__: Спеціальний метод конструктора, який викликається при створенні нового об'єкта. Встановлює атрибути екземпляра
# 3. start_engine: Метод, який викликається на екземплярі класу для виконання певної дії
# Атрибут класу — це змінна, яка зберігає дані про об'єкти певного класу або стильовий клас, що застосовується до елементів на веб-сторінці


# Створення класу та об'єкта.
# Створення об'єкта на основі класу є ключовим аспектом об'єктно-орієнтованого програмування (ООП)
# Об'єкти представляють конкретні екземпляри класу і володіють унікальними характеристиками та функціональністю, яку надає їхній клас
#
# Розглянемо крок за кроком, як створити об'єкт на основі класу за допомогою мови програмування Python:
# Крок 1: Визначення Класу:
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving {self.model} {self.make}")
# У цьому прикладі клас Car визначається з двома атрибутами: make і model
# Конструктор __init__ встановлює значення цих атрибутів при створенні нового об'єкта

# Крок 2: Створення Об'єкта
my_car = Car(make="Toyota", model="Camry")
# Створення об'єкта відбувається за допомогою визову конструктора класу
# У цьому випадку my_car - це об'єкт класу Car, який має значення make рівне "Toyota" і model рівне "Camry"
corolla = Car(make="Corolla", model="Camry")
fiesta = Car(make="Ford", model="Fiesta")
corolla.drive()
fiesta.drive()

# Коротше Запис
# Можна коротше записати цей процес в один рядок:
my_car = Car("Toyota", "Camry")
# Це еквівалентно попередньому прикладу
# Параметри передаються конструктору класу у тому ж порядку, в якому вони визначені в конструкторі

# Робота з Об'єктом
# Тепер, коли маємо створений об'єкт, можемо працювати з його атрибутами та методами:
print(my_car.make)    # Вивід: Toyota
print(my_car.model)   # Вивід: Camry
print()
# Цей приклад демонструє доступ до атрибутів об'єкта та виведення їх значень
# Створення об'єкта на основі класу дозволяє використовувати заздалегідь визначені структури та функціонал для створення об'єктів з однаковою або подібною функціональністю


# Атрибути класу та екземпляра.
# Атрибути класу є атрибутами, які належать самому класу, а не конкретному екземпляру цього класу
# !!! Вони є спільними для всіх екземплярів класу
class Car:
    # Атрибут класу
    wheels = 4
    pass
# У цьому прикладі wheels - це атрибут класу, який вказує на кількість коліс у всіх автомобілів, що належать класу Car

# До атрибутів класу можна отримати доступ, використовуючи ім'я класу:
print(Car.wheels)  # Вивід: 4

# Атрибути екземпляра належать конкретному екземпляру класу і можуть мати унікальні значення для кожного об'єкта
# Створення об'єкта класу Car
my_car = Car()
my_car.make = "Toyota"
my_car.model = "Camry"

# Атрибути екземпляра
print(my_car.make)   # Вивід: Toyota
print(my_car.model)  # Вивід: Camry
print()
# У цьому прикладі make і model є атрибутами екземпляра, які визначають виробника та модель конкретного автомобіля

# !!! Отже, відмінність полягає в тому, що атрибути класу спільні для всіх екземплярів
# !!! Тоді як атрибути екземпляра можуть відрізнятися для кожного об'єкта класу


# Методи екземпляра.
# !!! Методи екземпляра - це функції, які визначаються в межах класу і можуть бути викликані на об'єктах цього класу
# !!! Вони дозволяють здійснювати дії або повертати значення, пов'язані з конкретним екземпляром класу
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    # Метод екземпляра
    def start_engine(self):
        return "Engine started!"


# Створення об'єкта класу Car
my_car = Car("Toyota", "Camry")

# Виклик методу екземпляра
result = my_car.start_engine()
print(result)  # Вивід: Engine started!
print()
# У цьому прикладі start_engine є методом екземпляра класу Car, який можна викликати на об'єктах, створених з цього класу
# !!! Методи можуть отримувати доступ до атрибутів об'єкта та взаємодіяти з ними


# Динамічна зміна класу.
# !!! Об'єкти можуть динамічно змінювати свій стан та поведінку
# !!! Об'єкти в Python можуть динамічно змінювати свій стан та поведінку під час виконання програми. Це дозволяє гнучко адаптувати об'єкти під нові вимоги
#
# 1: Додавання нового атрибуту до екземпляра
# !!! Ви можете додавати нові атрибути до екземплярів класу просто присвоюючи їх:
# (Додавання нового атрибуту до екземпляра)
my_car.color = "blue"
# Тепер об'єкт my_car має новий атрибут color, який був доданий динамічно

# 2: Додавання нового методу до класу
# !!! Можливою є також динамічна зміна методів класу. Ви можете додати новий метод до класу під час виконання програми:
# Визначення нового методу екземпляра
def honk(self):
    return "Honk, honk!"

# Додавання нового методу до класу
Car.honk = honk

# Виклик нового методу екземпляра
result = my_car.honk()
print(result)  # Вивід: Honk, honk!
print()
# В цьому прикладі функція honk стає новим методом для всіх об'єктів класу Car
# Цей підхід дозволяє динамічно розширювати можливості класів та об'єктів під час виконання програми


# Статичні методи та методи класу.
# !!! Статичні методи належать класу, а не екземпляру класу
# !!! Вони викликаються на самому класі, а не на об'єктах, і не мають доступу до атрибутів екземпляра чи класу
# !!! Для визначення статичного методу використовується декоратор @staticmethod:
# @staticmethod - Не має доступу ні до атрибутів екземпляра (self), ні до атрибутів класу (cls). Це просто звичайна функція, яка “живе” всередині класу для зручності групування логіки
class MathOperations:
    @staticmethod
    def add(x, y):
        return x + y

# Виклик статичного методу
result = MathOperations.add(3, 5)
print(result)  # Вивід: 8
# У цьому прикладі метод add є статичним, оскільки він не отримує self (екземпляр) або cls (клас) як перший аргумент

# !!! Методи класу мають доступ до самого класу, але не до конкретних екземплярів
# !!! Вони викликаються на класі, а не на екземплярах, і можуть бути використані для операцій, які стосуються всього класу
# !!! Для визначення методу класу використовується декоратор @classmethod:
# @classmethod - може працювати з атрибутами класу, створювати нові об’єкти, змінювати загальні для всіх екземплярів властивості
class Person:
    count = 0

    def __init__(self, name):
        self.name = name
        Person.count += 1

    @classmethod
    def get_count(cls):
        return cls.count


# Виклик методу класу
print(Person.get_count())  # Вивід: 0

# Створення екземплярів класу
person1 = Person("Alice")
person2 = Person("Bob")

# Виклик методу класу через екземпляр
print(person1.get_count())  # Вивід: 2
print()
# В нас з'явились person1 + person2, вони проходять обидва __init__, потім get_count і ми отримуємо 2
# У цьому прикладі метод get_count є методом класу, оскільки він отримує cls (клас) як перший аргумент
# Він може отримати доступ до атрибутів класу, таких як count, і використовувати їх для виконання операцій, які стосуються всього класу


# Конструювання об'єкта класу.
# Конструктор є спеціальним методом, який викликається автоматично при створенні нового екземпляра класу
# У Python цей метод має ім'я __init__. Конструктор використовується для ініціалізації атрибутів об'єкта при його створенні
# !!! ініціалізація — це процес приведення об'єкта, програми або пристрою у стан готовності до використання шляхом надання початкових значень або налаштувань
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

# Створення об'єкта класу Dog
my_dog = Dog("Buddy", "Golden Retriever")

# Доступ до атрибутів екземпляра
print(my_dog.name)  # Вивід: Buddy
print(my_dog.breed)  # Вивід: Golden Retriever
print()
# У цьому прикладі конструктор приймає два аргументи, name і breed, і ініціалізує атрибути екземпляра класу Dog
# Коли створюється новий об'єкт my_dog, конструктор автоматично викликається і передає значення для ініціалізації атрибутів


# Наслідування та проблема ромба в ООП.
# Наслідування.
# !!! Наслідування в об'єктно-орієнтованому програмуванні — це механізм, за допомогою якого новий клас (підклас)
# може успадковувати атрибути та методи іншого класу (базового класу або суперкласу)
# !!! При цьому, підклас може розширювати чи модифікувати функціональність свого суперкласу
class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

# Створення об'єкта класу Dog
my_dog = Dog()

# Виклик методів
my_dog.speak()  # Вивід: Animal speaks
my_dog.bark()   # Вивід: Dog barks
print()
# У цьому прикладі клас Dog успадковує метод speak від класу Animal


# Проблема "ромба".
# Проблема "ромбу" (іноді відома як "амбігвітність ромба" або "ромбова амбігвітність") виникає, коли один клас успадковує від
# двох класів, які в свою чергу успадковують від одного і того ж класу
# У такому випадку виникає непевність, який саме метод слід викликати, оскільки обидва батьківські класи мають однаковий метод:
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(A):
    def show(self):
        print("C")

class D(B, C):
    pass

# Створення об'єкта класу D
obj = D()

# Виклик методів в порядку успадкування
obj.show()  # Що буде виведено: B
# !!! Python шукає метод show() (після obj.show (obj = D())) у такому порядку: У класі D — show() немає. У класі B — є show(). Тому він зупиняється тут і викликає B.show(), не доходячи до C чи A, і B.show() = "B". Так само, якщо б було б C на 1 місці в D(C, B). Воно б зупинилось на С, який також має show(), і вивело б - "С". А якщо ні в B, ні в C не буде show(), тоді воно піде шукати до батьківського класу - А
# У вищеприведеному прикладі, метод show успадковується як від B, так і від C. При виклику obj.show() виникає питання, який саме метод викликати
# Більшість мов програмування мають механізми вирішення цієї проблеми, такі як вказівка імені батьківського класу або механізми розділення методів
