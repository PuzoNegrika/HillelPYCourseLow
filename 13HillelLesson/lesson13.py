# Винятки та їх обробка.
# Винятки в програмуванні представляють невідповідності або помилки, що виникають під час виконання програми
# Вони можуть бути результатом різних ситуацій, таких як ділення на нуль, відсутність файлу або неправильний тип даних
#
# У Python і інших мовах програмування використовується механізм обробки винятків для управління винятковими ситуаціями
# Це включає використання конструкції try-except, яка дозволяє програмі коректно реагувати на помилки:
try:
    # блок коду, який може викликати виняток
    pass
except ВинятокТипу as e:
    # блок коду для обробки винятку
    pass


# Синтаксичні помилки та винятки.
# Синтаксичні помилки виникають під час обробки програмою, коли інтерпретатор Python намагається перекласти код, але не може знайти правильний шлях
# Вони є помилками на етапі написання коду і вимагають виправлення до виконання програми
#
# Винятки, навпаки, виникають під час виконання програми через непередбачувані обставини
# Обробка винятків дозволяє програмі коректно взаємодіяти з непередбаченими ситуаціями і виконувати необхідні дії для відновлення роботи програми або її коректного завершення
# Приклад синтаксичної помилки:
## if x > 0     #відсутній символ ":"
    ## print("x is positive")


# Для чого потрібні винятки.
# 1. Забезпечення коректності програми: Обробка винятків грає ключову роль у забезпеченні коректності програми під час її виконання
# Винятки дозволяють враховувати та реагувати на непередбачені ситуації, які можуть виникнути в ході роботи програми:
def divide_numbers(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        result = float('inf')  # уникнення ділення на нуль
    return result

# 2. Логування та відстеження помилок: Обробка винятків дозволяє докладно логувати помилки, що виникають під час виконання програми
# Це робить можливим відстеження та виправлення неполадок, що сприяє покращенню надійності програмного продукту:
import logging

try:
    # блок коду, який може викликати виняток
    pass
except Exception as e:
    logging.error(f'Помилка: {e}') # і тут буде помилка в е

# 3. Покращення користувацького досвіду: Коректна обробка винятків дозволяє програмі генерувати зрозумілі та інформативні
# повідомлення про помилки для користувача. Це робить взаємодію з програмою більш зручною та ефективною:
try:
    # блок коду, який може викликати виняток
    pass
except ValueError:
    print("Будь ласка, введіть коректні дані.")
except FileNotFoundError:
    print("Файл не знайдено. Перевірте шлях та ім'я файлу.")


# Конструкція try - except - finally - else.
# Основна конструкція для обробки винятків у Python — це try - except
# Код, який може викликати виняток, поміщується в блок try, а блок except визначає, як обробляти виняток
try:
    # Код, який може викликати виняток
    result = 10 / 0
except ZeroDivisionError:
    # Код обробки винятку
    print("Error: Division by zero")

# Додаткові блоки оператора try
# У конструкції try - except можуть бути додаткові блоки: !!!
# Блок finally: Код, розміщений у блоку finally, виконається незалежно від того, чи виник виняток, чи ні
# Це корисно для виконання завершальних операцій, таких як закриття файлів чи звільнення ресурсів:
try:
    # Код, який може викликати виняток
    result = int("123")
except ValueError as e:
    # Код обробки винятку
    print(f"Error: {e}")
finally:
    # Код, який виконується завжди
    print("End of try block")

# Блок else: Код у блоку else виконається тільки у випадку, якщо виняток не виникне (тобто except)
# Це може бути корисно для виконання операцій, якщо весь код у блоку try пройшов без помилок:
try:
    # Код, який може викликати виняток
    result = int("123")
except ValueError as e:
    # Код обробки винятку
    print(f"Error: {e}")
else:
    # Код, який виконується, якщо винятку не виникає
    print("Conversion successful")

# Використання цих блоків робить конструкцію try - except - else - finally потужним інструментом для обробки винятків та управління потоком виконання програми
# Якщо з повної конструкцією:
try:
    # Код, який може викликати виняток
    result = 10 / 2
except ZeroDivisionError:
    # Код обробки винятку
    print("Error: Division by zero")
else:
    # Код, який виконується, якщо винятку не виникає
    print("Division successful")
finally:
    # Код, який виконується завжди
    print("End of try-except block")
print()

# У цьому прикладі, якщо ділення на 2 пройде успішно, виконається блок else, виведеться "Division successful"
# Якщо виникне помилка ділення на нуль, обробиться виняток у блоку except і виведеться "Error: Division by zero"
# Незалежно від того, чи виникне виняток чи ні, блок finally завжди виконається, виведеться "End of try-except block"


# Оператори assert та raise.
# !!! Оператор assert використовується для перевірки певних умов та викидання винятку, якщо умова не виконується
# Це корисний механізм для вбудованих тестів та додаткової перевірки валідності даних:
x = 5
assert x > 0, "Value must be positive" # Це правда, отже буде виведено True, тобто код іде далі
print("True!")
print()
# У даному прикладі, якщо значення x не є позитивним, виникне виняток AssertionError, із повідомленням "Value must be positive"

# !!! Оператор raise використовується для явного виклику винятку
# Це дозволяє програмісту самостійно визначити та викинути виняток у визначеному місці коду
def validate_input(value):
    if value < 0:
        raise ValueError("Invalid value. Must be non-negative.")
    # Додаткові перевірки та операції з введеним значенням
## validate_input(-1) # помилка
# У цьому прикладі, якщо функції validate_input передати від'ємне значення, виникне виняток ValueError з повідомленням "Invalid value. Must be non-negative."
# Комбінування цих операторів з конструкцією try - except може забезпечити повноцінну систему обробки винятків та валідації в програмі, що підвищує її надійність та стійкість до непередбачених ситуацій


# Застосування оператора try.
# Оператор try використовується для захоплення винятків та виконання відповідного коду обробки
# Цей оператор є ключовим елементом механізму обробки винятків, дозволяючи програмі гнучко реагувати на непередбачені ситуації
try:
    # Код, який може викликати виняток
    result = int("abc")
except ValueError as e:
    # Код обробки винятку
    print(f"Error: {e}")
print()
# У даному прикладі виникає виняток ValueError, оскільки спроба конвертації рядка "abc" у ціле число неможлива
# Блок except виконує код обробки винятку та виводить повідомлення про помилку

# Ієрархія винятків.
# !!! У Python існує ієрархія винятків, де кожен клас винятку є підкласом базового класу BaseException
# Це дозволяє точніше обробляти винятки в залежності від їхнього типу та використовувати більш конкретні обробники для різних сценаріїв
#
# 1. Базовий клас винятків: BaseException
# Усі винятки у Python успадковані від класу BaseException.
# Це робить його базовим класом для всіх винятків, і його можна використовувати для загального оброблення всіх видів винятків:
try:
    # Код, який може викликати будь-який виняток
    pass
except BaseException as e:
    # Код обробки будь-якого винятку
    pass

# Категорії винятків.
# !!! Exception: Цей клас є підкласом BaseException і є базовим класом для більшості винятків у Python
# Багато вбудованих винятків, таких як ValueError, TypeError, успадковані від цього класу:
try:
    # Код, який може викликати будь-який виняток
    pass
except Exception as e:
    # Код обробки будь-якого винятку класу Exception
    pass

# ArithmeticError: Цей клас включає в себе винятки, які виникають при арифметичних операціях
# Наприклад, ZeroDivisionError є підкласом ArithmeticError:
try:
    # Код, який може викликати виняток арифметичного типу
    pass
except ArithmeticError as e:
    # Код обробки винятків арифметичного типу
    pass

# Використання класів ієрархії винятків дозволяє точно визначити, який тип винятку виник у програмі, і обробити його відповідним чином
# Це є важливим аспектом написання структурованого та надійного коду


# Виняток користувача.
# Іноді користувачам потрібно визначити свої типи винятків для більшої гнучкості в обробці помилок
# Для цього вони можуть створювати власні класи винятків, які успадковуються від вбудованих класів винятків:
class CustomError(Exception):
    pass

try:
    raise CustomError("This is a custom exception.")
except CustomError as ce:
    print(f"Custom error caught: {ce}")
# У цьому прикладі створено новий клас винятку CustomError, який успадковується від вбудованого класу Exception
# Потім використовується конструкція try - except для обробки цього конкретного типу винятку

# Створення власних класів винятків дозволяє розширити можливості обробки помилок, забезпечуючи додатковий контекст та інформацію про помилку
# Такий підхід робить код більш читабельним та обслуговуваним у випадках, коли специфіка помилок є важливою частиною логіки програми
