# Module and Package.
# Пакети.
# !!! У світі програмування термін "пакет" відноситься до способу організації коду, коли кілька модулів групуються разом
# Це дозволяє структурувати код, полегшує його розуміння та обслуговування, особливо великих проектах
# Пакети в Python використовуються для створення ієрархії та категоризації функцій та класів
#
# 1 - Структура пакету
# Структура пакету включає основні елементи:
# 1. __init__.py: Це основний файл, який вказує Python, що директорія має бути розглянута як пакет. Цей файл може залишатися порожнім або містити код ініціалізації пакету
# 2. Модулі: Файли, що містять код (наприклад, module1.py і module2.py). Модулі містять функції, класи чи інші елементи програми
# 3. Інші підпакети: Пакет може містити інші пакети, утворюючи ієрархію
#
# Приклад:
# Припустимо, у нас є пакет з назвою my_package. Його структура може виглядати так:
# my_package/
# |-- __init__.py
# |-- module1.py
# |-- module2.py
#
# 2 - Використання пакету
# Для використання пакету в іншому файлі або проекті ми можемо використовувати ключове слово import. Наприклад:
# Імпорт пакету
## import my_package

# Імпорт модуля з пакету
## from my_package import module1
# Такий підхід дозволяє нам використовувати функції чи класи, які містяться в модулях пакету, зазначаючи їхню назву після ключового слова import

# 3 - Зображення структури пакету
# Визуалізація структури пакету може виглядати приблизно так:
# my_package/
# |-- __init__.py
# |-- module1.py
# |-- module2.py
# Це відображення допомагає зрозуміти, як інтерпретується код в Python та як він організований в структурі пакетів
# Загалом, використання пакетів є важливою стратегією для раціонального організованого розробки великих та складних програм


# Модулі.
# !!! Модуль в програмуванні Python є файлом, який містить код, написаний мовою програмування Python.
# Основна ідея використання модулів полягає в тому, щоб розділити великі програми на менші та більш керовані частини
# Кожен модуль може містити функції, класи та змінні, які можна використовувати в інших програмах
#
# Створення та використання модуля
# Створимо файл module1.py, який буде представляти простий модуль:
## module1.py
##
## def greet(name):
##     return f"Hello, {name}!"
# У цьому файлі ми визначили функцію greet, яка повертає рядок з привітанням для заданого імені
# Тепер ми можемо використовувати цей модуль у іншому файлі чи скрипті. Наприклад:
# Використання модуля
from module1 import greet

print(greet("Alice")) # Hello, Alice!
print()
# У цьому прикладі ми імпортуємо функцію greet з модуля module1 та викликаємо її для створення привітання
# Модуль дозволяє нам групувати функції та дані для більш організованого та читабельного коду
# from ... import *, де * - це усе (тобто усе імпортувати)

# Застосування модулів:
# 1. Розділення коду: Модулі дозволяють розділити код на логічні частини, полегшуючи розробку та обслуговування
# 2. Повторне використання коду: Функції та класи в модулі можна використовувати в різних програмах та проектах
# 3. Організація проекту: Модулі є важливою частиною організації великих проектів, де код може бути розділений на декілька модулів для зручності
# 4. Забезпечення читабельності коду: Використання модулів дозволяє групувати схожі функції та класи, покращуючи читабельність коду
# Таким чином, модулі є ключовою концепцією в організації та структуруванні програм на мові програмування Python


# Поліморфізм.
# Що таке Поліморфізм?
# !!! Поліморфізм - це властивість системи взаємодіяти з об'єктами різних типів через спільний інтерфейс
# У мові програмування Python поліморфізм виражається у здатності об'єктів різних типів виконувати однакові дії чи відповідати
# за однакові методи чи властивості
# (Є фото під назвою: Polymorphism.img)


# Перевантаження операторів.
# У нашому прикладі, клас Point має метод __add__, який дозволяє перевизначити оператор + для об'єктів цього класу.
# При використанні оператора +, цей метод буде викликано
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Перевантаження оператора додавання
    def __add__(self, other):   # тобто це буквально "+", якщо десь буде "+" - буде викликана ф-ція
        return Point(self.x + other.x, self.y + other.y)

# Використання перевантаження оператора
point1 = Point(1, 2)
point2 = Point(3, 4)
result = point1 + point2
print(result.x, result.y)  # Вивід: 4 6
print()
# У цьому прикладі, при використанні оператора + між двома об'єктами Point, викликається метод __add__, який створює новий об'єкт Point
# з координатами, які є сумою координат об'єктів, на яких був викликаний оператор

# Інші приклади перевантаження операторів:  !!!
# 1. __sub__: Перевантаження оператора віднімання “-”
# 2. __mul__: Перевантаження оператора множення “*”
# 3. __truediv__: Перевантаження оператора ділення “/”
# 4. __eq__: Перевантаження оператора порівняння на рівність ”==”
# Це викликається, коли ви порівнюєте два об'єкти за допомогою оператора ==
def __eq__(self, other):
    return self.x == other.x and self.y == other.y
# Після перевантаження, ви можете використовувати ці оператори для об'єктів вашого класу так, як це призначено для вас в вашому контексті програми


# Перевантаження операторів порівняння.
# !!! У Python ви можете перевизначити різні оператори порівняння для своїх класів, щоб забезпечити коректну роботу з об'єктами цих класів в контексті порівняння
#
# Перевантаження оператора менше <
# У вашому прикладі, метод __lt__ дозволяє перевизначити оператор менше < для об'єктів класу Person
# Це дозволяє порівнювати об'єкти цього класу за визначеним вами критерієм (у цьому випадку, за віком)
class Person:
    def __init__(self, age):
        self.age = age

    # Перевантаження оператора менше
    def __lt__(self, other):    # буквально якщо з'являється "<" - викликається ця ф-ція
        return self.age < other.age

# Використання перевантаження оператора менше
person1 = Person(25)
person2 = Person(30)
result = person1 < person2
print(result)  # Вивід: True
print()
# У цьому прикладі, якщо ви порівнюєте два об'єкти Person за допомогою оператора <, викликається метод __lt__, який порівнює їх за віком

# Інші оператори порівняння:  !!!
# 1. __eq__: Перевантаження оператора порівняння на рівність ==
# 2. __ne__: Перевантаження оператора порівняння на нерівність !=
# 3. __le__: Перевантаження оператора менше або дорівнює <=
# 4. __gt__: Перевантаження оператора більше >
# 5. __ge__: Перевантаження оператора більше або дорівнює >=
# Це дозволяє вам визначити поведінку порівняння для вашого класу в залежності від ваших потреб


# Інкапсуляція у дії.
# Три рівні доступу.
# !!! Інкапсуляція — це об'єднання атрибутів і методів всередині класу, яке запобігає доступу зовнішніх класів до атрибутів і методів даного класу та їх змін
# !!! Три рівні доступу в ООП (public, protected, private) визначають, як об'єкти взаємодіють один з одним та які дані можуть бути доступні для зовнішнього користування
# Ці рівні дозволяють контролювати, які частини класу є внутрішніми та призначеними для зовнішнього використання, де:
# 1. Public: Атрибути та методи доступні з будь-якого місця коду
# 2. Protected: Атрибути та методи доступні у межах класу та його підкласів
# 3. Private: Атрибути та методи доступні тільки у межах класу

# Для чого вони потрібні:  !!!
# 1. Контроль доступу: Дозволяє регулювати, які частини класу можуть бути використані ззовні та які повинні залишатися внутрішніми
# 2. Безпека та Ізоляція: Захищає внутрішню реалізацію класу та його деталі від несанкціонованого доступу
# 3. Управління Інтерфейсом: Дозволяє визначити громадський інтерфейс класу, представляючи лише ті атрибути та методи, які призначені для використання ззовні
# 4. Запобігання Конфліктам: Зменшує ймовірність конфліктів імен та неправильного використання частин класу
# Загалом, три рівні доступу надають зручний механізм для організації та контролю взаємодії між об'єктами та частинами програмного коду


# Public (Громадський) рівень доступу
# !!! Громадський рівень доступу дозволяє атрибутам та методам класу бути доступними з будь-якого місця коду, включаючи зовнішній код,
# який використовує клас В Python це досягається за допомогою використання громадського (public) модифікатора доступу
#
# Приклад:
class Example:
    def __init__(self):
        # Громадський атрибут
        self.public_attribute = "Public"

    # Громадський метод
    def public_method(self):
        return "Public method"

# Використання громадського рівня доступу
obj = Example()

# Доступ до громадського атрибуту
print(obj.public_attribute)  # Вивід: Public

# Виклик громадського методу
print(obj.public_method())    # Вивід: Public method
# Особливості:  !!!
# 1. Громадські атрибути та методи можуть бути викликані з будь-якого місця програми, навіть зовні класу
# 2. Це робить атрибути та методи легко доступними для використання ззовні та надає гнучкість у взаємодії з класом
# 3. Громадські атрибути та методи зазвичай представляють інтерфейс, який призначений для використання користувачами класу

# Переваги та Недоліки Громадського Рівня Доступу:  !!!
# 1. Переваги:Простота використання та зрозумілість коду. Зручний інтерфейс для користувачів класу
# 2. Недоліки:Зменшується контроль над внутрішньою реалізацією класу. Робить клас вразливим до неправильного використання та змін ззовні


# Protected (Захищений) рівень доступу.
# !!! Захищений рівень доступу використовує модифікатор _ перед ім'ям атрибута чи метода
# !!! Це дозволяє атрибутам та методам бути доступними тільки у межах класу та його підкласів
#
# Приклад:
class Example:
    def __init__(self):
        # Захищений атрибут
        self._protected_attribute = "Protected"

    # Захищений метод
    def _protected_method(self):
        return "Protected method"

# Використання захищеного рівня доступу
obj = Example()

# Доступ до захищеного атрибуту
print(obj._protected_attribute)  # Вивід: Protected

# Виклик захищеного методу
print(obj._protected_method())    # Вивід: Protected method

# Особливості:  !!!
# 1. Захищені атрибути та методи можуть бути використані тільки у межах класу та його підкласів
# 2. Це забезпечує деякий рівень захисту від неправильного використання або змін ззовні класу
# 3. Захищені атрибути та методи використовуються для інформації та функціональності, які призначені для внутрішнього використання класу, але можуть бути доступні для підкласів для спеціалізації чи розширення

# Переваги та Недоліки Захищеного Рівня Доступу:  !!!
# 1. Переваги: Забезпечує контроль над внутрішньою реалізацією класу. Забезпечує безпеку від неправильного використання та змін ззовні
# 2. Недоліки: Захищений рівень доступу все ще дозволяє звертатися до атрибутів та методів ззовні класу, якщо користувач так вирішить


# Private (Приватний) рівень доступу.
# !!! Приватний рівень доступу використовує модифікатор __ перед ім'ям атрибута чи метода
# !!! Це дозволяє атрибутам та методам бути доступними тільки у межах класу
# !!!  Однак, важливо відзначити, що в Python не існує справжнього "приватного" рівня доступу, інформація про атрибути і методи може бути отримана через ім'я класу, але це не рекомендується
#
# Приклад:
class Example:
    def __init__(self):
        # Приватний атрибут
        self.__private_attribute = "Private"

    # Приватний метод
    def __private_method(self):
        return "Private method"

# Використання приватного рівня доступу
obj = Example()

# Спроба доступу до приватного атрибуту (не рекомендовано)
print(obj._Example__private_attribute)  # Вивід: Private

# Спроба виклику приватного методу (не рекомендовано)
print(obj._Example__private_method())    # Вивід: Private method
## print(obj.__private_method())  # ПОМИЛКА: 'Example' object has no attribute '__private_method'
# У прикладі вище __private_attribute і __private_method визначені як приватні для класу Example
# !!! Проте, доступ до них можна отримати, вказавши ім'я класу з подвійним підкресленням перед іменем атрибута чи метода
# Такий доступ, однак, не рекомендується, оскільки це порушує ідею інкапсуляції та може веде до непередбачуваного поведінки

# Особливості:  !!!
# 1. Ім'я зміни: Приватні атрибути та методи отримують нове ім'я, яке включає ім'я класу з подвійним підкресленням перед оригінальним ім'ям (наприклад, _Example__private_attribute)
# 2. Забезпечення інкапсуляції: Хоча доступ до приватних елементів може бути отриманий, використовуючи спеціальне ім'я, це не рекомендується, щоб підтримувати принцип інкапсуляції

# Переваги:  !!!
# 1. Контроль доступу: Забезпечує обмежений доступ до атрибутів та методів, зменшуючи можливість конфліктів та непередбачуваного використання
# 2. Інкапсуляція: Допомагає утримувати деталі реалізації класу в межах класу, що поліпшує інкапсуляцію

# Недоліки:  !!!
# 1. Не справжній приватний доступ: Здатність отримати доступ до приватних елементів через ім'я класу зменшує ефективність захисту приватних даних
# 2. Порушення оголошень: Звертання до приватних елементів через ім'я класу є неявним порушенням угоди між розробниками та може призвести до непередбачуваного поведінки
# 3. Ускладнення читабельності коду: Ім'я зміни можуть зробити код менш зрозумілим та ускладнити його обслуговування
# Хоча приватний рівень доступу не є абсолютною гарантією конфіденційності, його використання дозволяє підтримувати чистий та добре структурований код, який важливий для розробки стабільних та безпечних програм