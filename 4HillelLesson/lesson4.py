# Присвоєння значень зрізам
# Зрізи можна використовувати не тільки для отримання підсписків, але і для зміни елементів списку. Якщо зрізу списку присвоїти значення, це значення відобразиться як вміст вашого списку
# кількість елементів збігається

first_list = [2, 4, 7, 11, 0, 999, 8]
first_list[1:4] = [12, 13, 14]
print(first_list) # [2, 12, 13, 14, 0, 999, 8]

# кількість елементів, які змінюємо, більше
first_list = [2, 4, 7, 11, 0, 999, 8]
first_list[1:4] = [23] # беремо цілий список, і заміняємо 1 значенням усе
print(first_list)

# кількість елементів, які змінюємо, менша
first_list = [2, 4, 7, 11, 0, 999, 8]
first_list[1:3] = [33, 34, 35]
print(first_list) # [2, 33, 34, 35, 11, 0, 999, 8]
print()

# Інші методи списків
# count() - повертає кількість входжень елемента до списку. Рахує в списку дублікати
first_list = [3, 4, 5, 4, 5, 34, 5, 35, -2]
print(first_list.count(5))  # 3 (три п'ятірки)
first_list.count(9) # 0

# index() - метод списку, який дозволяє дізнатися індекс чи позицію елемента у послідовності.
# Іншими словами, цей метод шукає елемент у списку та повертає його індекс (вона шукає тільки 1 входження). Коли знайшло - запиняється
first_list = [3, 4, 5, "rr", 5, 34, 5, 35, -2]
print(first_list.index(3)) # 0 - тому, що 3 стоїть на першому місці та її індекс дорівнює 0
# ValueError якщо такого елемента у списку немає
# print(first_list.index(9)) 9 нема, тому буде помилка ValueError

# sort() - сортує елементи списку на місці. Тобто сортування відбувається у списку
first_list = [3, 4, 5, 4, 5, 34, 5, 35, -2]
first_list.sort()
print(first_list)  # [-2, 3, 4, 4, 5, 5, 5, 34, 35]
# reverse=True - сортування від більшого до меншого
first_list = [3, 4, 5, 4, 5, 34, 5, 35, -2, 3, 14, 14]
first_list.sort(reverse=True)
print(first_list) # [35, 34, 14, 14, 5, 5, 5, 4, 4, 3, 3, -2]
# Елементи списку, який потрібно відсортувати, мають бути одного типу!:
# first_list = [3, 4, '5', 4, 5, '34', 5, 35, '-2', 3, 14, 14]
# first_list.sort() # TypeError: '<' not supported between instances of 'str' and 'int'

# reverse() - перебудовує елементи списку у зворотному порядку (перебудовує елементи в зворотнєму напрямку)
# Даний метод модифікує список на місці, повертаючи None
first_list = [3, 4, 5, 4, 5, 34, 5, 35, -2, 3, 14, 14]
first_list.reverse()
print(first_list)  # [14, 14, 3, -2, 35, 5, 34, 5, 4, 5, 4, 3]

# remove(element) - видаляє зі списку зазначений елемент. Якщо елемент відсутній у списку, формується виняток ValueError
first_list = [3, 4, 5, 4, 5, 34, 5, 35, -2, 3, 14, 14]
first_list.remove(3)
print(first_list)  # [4, 5, 4, 5, 34, 5, 35, -2, 3, 14, 14], нема більше трійки
# first_list.remove(993) # ValueError: list.remove(x): x not in list

# copy() - робить поверхневу копію списку (не рекомендовано для копій списків, наприклад)(створює посилання на список, а не його копію)
# Тобто в даному випадку створюється новий список, але елементи цього списку вказують на ті ж об'єкти, що і в оригінального списку
first_list = [56, 6, 8, 7]
tmp = first_list.copy() # створюємо копію
print(id(first_list) == id(tmp))  #  False

# clear() - видаляє всі елементи зі списку
tmp = [[1, 2, 3], [4, 5, 6]]
tmp.clear()
print(tmp) #  []
print()

import copy
# коли потрібно створити копію списку, а не посилання на список
first_list = [[1, 2, 3], [4, 5, 6]]
tmp = copy.deepcopy(first_list)
tmp[0][0] = 50
print(tmp) #  [[50, 2, 3], [4, 5, 6]]
print(first_list) #  [[1, 2, 3], [4, 5, 6]]
print(id(tmp[0]) == id(first_list[0])) #  False
print()

# Вбудовані функції min, max, all, any
# min() - знаходження мінімального значення в послідовності
first_list = [2, 4, 7, 11 , 0, -2, 8]
print(min(first_list))  # -2

# max() - знаходження максимального значення в послідовності
first_list = [2, 4, 7, 11 , 0, -2, 8]
print(max(first_list))  # 11

# ВАЖЛИВО! Для функцій min і max, всі елементи списку повинні належати до одного типу даних
# first_list = [2, 4, 7, 11 , '0', -2, 8]
# # TypeError: '>' not supported between instances of 'str' and 'int'
# max(first_list)

# Функція all повертає True у разі, коли всі елементи послідовності можна інтерпретувати як True
# Це можна уявити як поєднання кількох логічних умов за допомогою оператора and
print(all([1, True, 10])) # True
print(all([4 > 2, True, 5 == 5])) # True
print(all([4 > 2, True, 5 != 5])) # False

# Функція any повертає True у разі, коли хоча б один елемент послідовності можна інтерпретувати як True
# Це можна уявити як поєднання кількох логічних умов за допомогою оператора or
print(any([False, 1 == 1, False])) # True
print(any([]))  # False
print(all([])) #  True Будьте обережні!
# Щоб було False - має знайти УСІ False
print()

# Цикл
# Цикл - це конструкція в програмуванні, яка дозволяє виконувати одну або кілька команд багато разів, поки виконується певна умова або досягається певний результат. Цикли допомагають автоматизувати повторювані дії, зменшити обсяг коду та зробити програму ефективнішою. Існує кілька видів циклів, таких як:
# Цикл з передумовою, який перевіряє умову перед кожною ітерацією та виконує тіло циклу, якщо умова істинна. Наприклад, цикл while в багатьох мовах програмування
# Цикл з післяумовою, який виконує тіло циклу спочатку, а потім перевіряє умову після кожної ітерації та продовжує цикл, якщо умова істинна. Наприклад, цикл do-while (нема в пайтоні) в деяких мовах програмування
# Цикл з лічильником, який використовує змінну, яка збільшується або зменшується на кожній ітерації та виконує тіло циклу, поки змінна не досягне певного значення. Наприклад, цикл for в багатьох мовах програмування
# Цикл по колекції, який проходить по всіх елементах колекції, такої як список, масив, словник тощо, та виконує тіло циклу для кожного елемента. Наприклад, цикл foreach в деяких мовах програмування
# while - використовується в Python для неодноразового виконання певної інструкції до тих пір, поки задана умова залишається істинною
# for - вузькоспеціалізована версія циклу. Призначений для проходу по послідовностях, що ітеруються

# Цикл while
# Цикл while в Пайтон - це конструкція, яка дозволяє виконувати одну або кілька команд багато разів, поки виконується певна умова. Умова записується до тіла циклу і перевіряється перед кожною ітерацією. Якщо умова істинна, то виконується тіло циклу, якщо хибна - то цикл зупиняється. Цикл while використовується, коли невідомо точне значення кількості проходів виконання циклу. Синтаксис циклу while в Пайтон такий:
#while <умова>:
#   <команди>

x = 10 # присвоюємо початкове значення змінній x
counter = 0
while counter < x: # запускаємо цикл при умові x <= 10
	print("Hello World") # друкуємо значення x
	counter += 1 # збільшуємо значення x на 1
print('End')

# Цикл while в Пайтон може мати також оператори break, continue і else, які дозволяють керувати ходом циклу
# Оператор break припиняє цикл негайно, оператор continue переходить до наступної ітерації, а оператор else виконується, коли цикл закінчується без використання break
# continue - перериває поточну ітерацію циклу і відразу переходить до наступної
# break - припиняє виконання циклу
number = 0
while number < 10:
    number += 1 # До continue !!!!
    if number == 3:
        continue # викидує нас з циклу, але не завершає його
    if number == 8:
        break
    print(number) # не доберемося до сюди

# Конструкція while - else
# Як і умовний оператор if, так і цикл while можна доповнити блоком else. Принцип роботи такого оператора є досить цікавим
# Блок else виконається лише в тому випадку, якщо цикл завершиться нормально. Якщо ж цикл буде перервано за допомогою оператора break або ще якимось чином, то цей блок буде пропущено.
number = int(input("input positive number "))
i = 2
while i < number:
    if number % i == 0:
				# Якщо число ділиться без залишку на інше число, то це число не є простим
        print("It is not a prime number")
        break
    i = i + 1
else: # виконається тільки якщо break в циклі не буде викликаний.
    print("It is a prime number")
print()

# Використання вкладених циклів while
# Як і умовний оператор if, так і цикл while можна вкласти всередину іншого циклу while. Вийде цикл у циклі
# виведе на екран прямокутник із символів «*».
a = int(input("Input a "))
b = int(input("Input b "))
i = 0
while i < a: # Висота
    j = 0
    while j < b: # ширина
        print("*", end='') # рядок не буде переведено
        j += 1
    print()
    i += 1
print()

print("Hello World", "oleksii", end="!!!", sep="***") # Hello World***oleksii!!!
print()


# Цикл for в Пайтон - це конструкція, яка дозволяє виконувати одну або кілька команд багато разів, перебираючи елементи певної послідовності або ітерабельного об'єкта. Послідовність може бути списком, кортежем, рядком, словником, набором або іншим типом, який підтримує ітерацію. Цикл for використовується, коли відомо точне значення кількості проходів виконання циклу або коли потрібно виконати однаковий код для кожного елемента послідовності. Синтаксис циклу for в Пайтон такий:
# for <змінна> in <послідовність>: (послідовністью може бути: кортеж, список, сет, словник ітп)
#       <команди>
# <змінна> - це ім'я змінної, яка приймає значення кожного елемента послідовності на кожній ітерації циклу
# <послідовність> - це ім'я або вираз, який повертає послідовність або ітерабельний об'єкт, по якому буде виконуватися цикл
# <команди> - це блок коду, який виконується для кожного елемента послідовності. Блок коду має мати відступ від початку рядка
fruits = [12, 542, "rtad", {}, True, False, None, 14.2, [434, 23, 21]] # [...,[...]] - додаткові [] рахуються як 1 елемент
for apple in fruits:
    # example ми використовуємо в якості послідовность, по якій буде цикл працювати
    if fruits == "rtad":
        continue
    print(fruits)
print()

# Функція enumerate()
# Функція enumerate отримує як аргумент об'єкт, що ітерується, і повертає два значення - число з послідовності, яке за замовчуванням починається з 0, і елемент з об'єкта, що ітерується
lst = [4, 6, 8, 7]
for i, el in enumerate(lst):
    print(i,"->", el)
# 0 -> 4
# 1 -> 6
# 2 -> 8
# 3 -> 7
print()

# Функція range()
# Генератор числової послідовності range в Пайтон - це вбудована функція, яка дозволяє створювати арифметичні послідовності цілих чисел з заданим початком, кінцем і кроком. Генератор range повертає ітерабельний об'єкт, який можна використовувати в циклах for, функціях len, list, tuple та інших операціях. Генератор range ефективно використовує пам'ять, оскільки він не зберігає всі числа послідовності, а лише потрібні параметри для їх генерації
# Синтаксис генератора range такий:
# range(stop) # створює послідовність від 0 до stop-1 з кроком 1
# range(start, stop) # створює послідовність від start до stop-1 з кроком 1
# range(start, stop, step) # створює послідовність від start до stop-1 з заданим кроком step
r = range(11, 1) # r є об'єктом range
for i in r: # i приймає значення 1, 3, 5, 7, 9
    print(i) # виводить на екран кожне значення

# Якщо є необхідність, можна вказати значення початку. За промовчанням це 0
list(range(3, 10)) # [3, 4, 5, 6, 7, 8, 9]
# можна вказати значення кроку. За замовчуванням це 1
list(range(3, 10, 2)) # [3, 5, 7, 9]
# Послідовність може бути негативною у бік збільшення значення
list(range(-13, -10)) # [-13, -12, -11]
# Послідовність може бути негативною у бік зменшення значення
list(range(0, -10, -1)) # [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]

# Модуль random
# Модуль random в Пайтон - це вбудований модуль, який надає функції для генерування псевдовипадкових чисел, букв, вибору випадкових елементів з послідовностей та інших операцій, пов'язаних з випадковістю. Модуль random використовує алгоритм Mersenne Twister, який є одним з найбільш протестованих і надійних генераторів випадкових чисел
# Ось деякі з основних функцій модуля random:
# random.random() - повертає випадкове число з діапазону від 0.0 до 1.0
# random.randint(a, b) - повертає випадкове ціле число з діапазону від a до b включно
# random.randrange(start, stop, step) - повертає випадкове ціле число з послідовності, що починається з start, закінчується stop (не включаючи) і має крок step
# random.choice(seq) - повертає випадковий елемент з непорожньої послідовності seq, такої як список, рядок, кортеж тощо
# random.shuffle(seq) - перемішує елементи послідовності seq випадковим чином
# random.sample(population, k) - повертає список з k випадкових елементів з населення population, яке може бути будь-яким ітерабельним об'єктом
# Заповнити список випадковою кількістю елементів від 6 до 15 та випадковим значенням від 1 до 100, і порахувати їхню суму
import random
my_list = []
# Не найоптимальніший варіант рішення
for i in range(random.randint(6, 15)):
    my_list.append(random.randint(1, 1000))
print(my_list) # 10 рандомних чисел (включно 6 і 15) від 1 до 1000

summa = 0
for element in my_list:
    summa += element
print(summa) # сумма чисел

# варіант створення списків за допомогою генератора списків (спискове включення)
my_list = [random.randint(1, 100) for i in range(random.randint(6, 15))]
print(my_list) # 10 чисел від 1 до 100

# Знаходження суми елементів послідовності за допомогою вбудованої функції sum
print(sum(my_list))

# оптимальний варіант рішення
my_list = [random.randint(1,100) for i in range(random.randint(6, 15))]
print(my_list)
print(sum(my_list))

# pop - видалення елементу по його індексу