# Що таке рядок?
# Рядок — це послідовність будь-яких символів укладених в лапки. У Python рядки відносяться до НЕЗМІНЮВАННОГО типу даних !!!
# Літерали рядків оголошуються як текст, укладений в одинарні, подвійні або потрійні лапки. Як і у разі списків, так і у разі рядків, позиція окремого символу відраховується від початку рядка. Перший символ рядка має індекс 0. Звернення до окремого елемента рядка має такий самий синтаксис, як і до елемента списку
# Створюємо рядок
my_string_1 = 'I like Python'
my_string_2 = "I like Python"
# ПРОБІЛ ТЕЖ РАХУЄТЬСЯ ЯК СПИСОК !!!
# Виводимо тип
print(type(my_string_1)) # виведе: <class 'str'>, string = рядок !!!

# Якщо потрібні одинарні лапки всередині рядка
my_string_1 = "I 'like' Python"
print(my_string_1) # виведе: I 'like' Python

# Якщо потрібні подвійні лапки всередині рядка
my_string_1 = 'I "like" Python'
print(my_string_1[4]) # i

# За допомогою слеша, можна екранувати лапки
my_string_1 = "I \"like\" Python"
print(my_string_1) # виведе: I "like" Python

# Потрійні подвійні лапки використовуються тоді, коли потрібний текст із перенесенням рядків
my_string = """Python
        ""is""
    awesome
"""

# За допомогою функції str можна з будь-якого типу даних створити рядок
digits = str(3654)
# Виглядає як число, але це рядок
print(digits) # виведе: 3654
print(type(digits)) # виведе: <class 'str'>

# Коли рядок виглядає як ціле число, його можна перетворити саме до цілого числа за допомогою функції int
digits = int(digits)
print(type(digits)) # виведе: <class 'int'>
print()

# Рядки мають часткову функціональність списків
# А саме:
# 1 - Як і списки, рядки можна складати  !!!
# 2 - Як і списки, рядки можна множити на ціле число  !!!
# 3 - Як і у разі списків, доступ до елемента рядка для читання можливий за індексом. Також працюють зрізи  !!!
# Приклади:
my_string = "Python " + "is" + " awesome!"
print(my_string) # виведе: Python is awesome!

my_string = "Go" * 10
print(my_string) # виведе: GoGoGoGoGoGoGoGoGoGo

# Отримання довжини рядка
my_string = "Python"
print(len(my_string)) # виведе: 6, за допомогою len

my_string = ""
print(len(my_string)) # виведе: 0
my_string = " "
print(len(my_string)) # виведе: 1, бо пробіл - це також символ

print(len('\n')) # 1 байт

# Доступ до елементів рядка за індексом
my_string = "Python is awesome"
print(my_string[0]) # виведе: P
print(my_string[1]) # виведе: y
print(my_string[6]) # виведе: " " (пробіл)

# Доступ до елементів рядка за негативним індексом (від кінця)
print(my_string[-1]) # виведе: e
print(my_string[-2]) # виведе: m

# Зрізи працюють так само як і в списках, тільки в результаті ми отримуємо новий рядок
my_string1 = "Python is awesome"
my_string = my_string1[:6] # відрізає з 6 не включно і до кінця
print(my_string) # виведе: Python

my_string = my_string1[7:9]
print(my_string) # виведе: is
print(my_string1[:]) # виведе: Python is awesome
my_string = my_string1[7:9]

# Змінити символ за індексом НЕ МОЖНА! Рядки - незмінний тип !!!
# my_string = "123456789"
# my_string[6] = "N" # TypeError: 'str' object does not support item assignment

# Можна скористатися конкатенацією рядків, розділяючи рядок на потрібні фрагменти
my_string = "123456789"
my_string = my_string[:6] + 'N' + my_string[7:] # 6 і 7 не включно! Тобто ззаду
print(my_string) # виведе: 123456N89

# Рядок є типом даних, що ітерується, тому його можна передавати в цикл for
my_string = "python"
for char in my_string:
    print(char) # Кожна буква з нового рядка

# Перевірка наявності підрядка у рядку
my_string = "I like Python"
print("lik" in my_string) # виведе: True
print("e" in my_string) # виведе: True
print("liek" in my_string) # виведе: False
if "lik" in my_string:
    print("lik")
print()

# Деякі методи характерні для рядків
# upper() Підвищує регістр символів
my_string = "I like Python"
my_string1 = my_string.upper() # Результат зберігаємо в іншій змінній
print(my_string1) # виведе: I LIKE PYTHON
my_string1 = my_string.upper()[2] # L
print(my_string1)
my_string1 = my_string[:-6] + my_string[-6:].upper() # I like PYTHON
print(my_string1)
# Початковий рядок залишився незмінним
print(my_string) # виведе: I like Python

# lower() Знижує регістр символів
my_string = my_string.lower()
print(my_string) # виведе: i like python

# title() Першу літеру кожного слова переводить у верхній регістр, а решта в нижній
my_string = "i like python"
my_string = my_string.title()
print(my_string)  # виведе: I Like Python

# swapcase() Перекладає символи нижнього регістру у верхній, а верхнього у нижній (тобто типу реверс)
my_string = "I Like Python"
my_string = my_string.swapcase()
print(my_string) # виведе: i lIKE pYTHON

# ljust(), rjust(), center() Робить довжину рядка не меншого width, за необхідності заповнюючи останні (перші) символи символом fillchar
my_string = "I Like Python"
# вирівнювання по лівому краю
print(my_string.ljust(20, "*"))  # виведе: I Like Python*******, справа буде виведено в кінець зірочки
 # вирівнювання з правого краю
print(my_string.rjust(20, "+")) # виведе: +++++++I Like Python, зліва буду виведено в початок плюси
 # вирівнювання по центру
print(my_string.center(20, "-")) # виведе: ---I Like Python----

# replace() замінити в рядку один підрядок на інший
my_string = "I like PHP, PHP, PHP,"

# можна вказувати кілька методів поспіль
my_string1 = my_string.replace("PHP", "Python").replace(',', '!')
print(my_string1) # виведе: I like Python! Python! Python!

# оригінальний рядок не змінився
print(my_string)  # виведе: I like PHP, PHP, PHP,

# можна замінити не все, а лише певну кількість
my_string1 = my_string.replace("PHP", "Python", 1) # 1 - перше входження
print(my_string1)  # виведе: I like Python, PHP, PHP,

my_string1 = my_string.replace("PHP", "Python", 2) # 2 - друге входження
print(my_string1)  # виведе: I like Python, Python, PHP,

# якщо у рядку немає такого символу, то помилки все одно не буде!
my_string1 = my_string.replace('*', '//')
print(my_string1)  # виведе: I like PHP, PHP, PHP,
print()

# split() розбити рядок на підрядки
# В результаті роботи цього методу, ми ЗАВЖДИ отримуємо список
# За замовчуванням, розбиття відбувається за пробілом та/або перенесенням рядка
my_string = "I like   s,   Python"
lst = my_string.split()
lst2 = my_string.split(sep=",")
print(lst) # виведе: ['I', 'like', 's,' 'Python']
print(lst2) # виведе: ['I like   s,'  'Python'] # тобто розбив на два списки

# Замість пробілу можна використовувати будь-який необхідний вам символ
my_string = "I like Python"
lst = my_string.split('i')
print(lst)  # виведе: ['I l', 'ke Python'] # вивела 1 список до i, а другий - усе інше, після i

lst = my_string.split('I')
print(lst)  # виведе: ['', ' like Python']

# Якщо в рядку немає символу, за яким потрібно зробити розбиття, ми все одно отримаємо список, і в ньому буде лише один елемент у вигляді початкового рядка
my_string = "I like Python"
lst = my_string.split('w')
print(lst) # виведе: ['I like Python']

# join() Повертає рядок, зібраний з елементів зазначеного об'єкта, що підтримує ітерування (список, рядок, тощо)
my_lst = ['I', 'like', 'Python']
# пробіл, як символ для з'єднання елементів зі списку
_string = " ".join(my_lst) # в дужках - ДО ЧОГО ми додаємо
print(_string) # виведе: I like Python

# рядок, це також об'єкт, що ітерується
my_str = "I like Python"
_string = "_".join(my_str)
print(_string) # виведе: I_ _l_i_k_e_ _P_y_t_h_o_n

# символ для з'єднання буде додаватися лише між елементами
string = "-".join('t')
print(string) # виведе: t

string = "-".join('tt')
print(string) # виведе: t-t

# join працює тільки з типом даних "рядок”
# lst = [2, 3, 5] # join працює тільки з типом даних "рядок"
# print("".join(lst)) # TypeError: sequence item 0: expected str instance, int found

# варіант того, як можна "на льоту" перевести число в рядок
x = "".join([str(y) for y in lst])
print(x) # виведе: 235
print(type(x)) # виведе: <class 'str'>
print()

# strip() Повертає копію рядка, з обох кінців якого усунуті зазначені символи
# За замовчуванням забираються пробіли
my_string = "   I like Python!          "
my_string = my_string.strip()
print(my_string) # виведе: I like Python!
my_string = "   I like Python!          !"
my_string = my_string.strip()
print(my_string) # виведе: I like Python!          !


# Замість пропуску можна використовувати інший символ
my_string = my_string.strip("!")
print(my_string) # виведе: I like Python, фільтруємо ДО ЗНАКУ "!"

# Якщо перед символом, який потрібно замінити, є інший символ, заміна не відбудеться
my_string = "I like Python!?"
my_string = my_string.strip("!") # does not work
print(my_string) # виведе: I like Python!?

# lstrip прибирає символ зліва, а rstrip прибирає праворуч
my_string = "@I like Python!"
my_string = my_string.lstrip("@") # lstrip прибирає зліва
print(my_string) # виведе: I like Python!

my_string = my_string.rstrip("!") # rstrip прибирає праворуч
print(my_string) # виведе: I like Python

# find() Повертає найменший індекс, за яким виявляється початок зазначеної підрядки у вихідному
my_string = "Beautiful is better than ugly"
print(my_string.find('B')) # виведе: 0

ind = my_string.find('e')
print(ind) # виведе: 1 (найменший індекс, який шукає початковий вхід)

# count повертає кількість входжень підрядка sub в діапазоні [start, end]
print(my_string.count('e'))  # виведе: 3, три букви е було знайдено в входженні

# Пошук індексу наступного елемента
ind = my_string.find('e', ind + 1)
print(ind)  # виведе: 14
print(my_string.find('e', ind + 1))  # виведе: 17

# Якщо елемента більше немає в рядку, то помилки не буде!
print(my_string.find('e', 20))  # виведе: -1

# is - перевірка на bool`евое значення

# isalpha() перевіряє, чи рядок складається лише з літер
my_string = "Beautiful is better than ugly"
# є символи, які не є літерами (пробіл) !!!
print(my_string.isalpha()) # виведе:  False
my_string = "Beautiful"
print(my_string.isalpha()) # виведе: True

# isdigit() перевіряє, чи рядок складається лише з цифр
# isalnum() перевіряє, чи рядок складається лише з цифр та з літер
my_string = '123456'
print(my_string.isdigit()) # виведе: True
my_string = '123456O' # тут не нуль 0
print(my_string.isdigit()) # виведе: False
print(my_string.isalnum()) # виведе: True
my_string = '123456O!'
print(my_string.isalnum()) # виведе: False
print()

# Методи islower(), isupper(), startswith(), endswith(), istitle()
my_string = 'Simple is better than complex.'

# Всі літери в нижньому регістрі?
print(my_string.islower()) # виведе: False
# Всі літери у верхньому регістрі?
print(my_string.isupper()) # виведе: False
# Починається рядок із потрібних символів?
print(my_string.startswith('Si')) # виведе: True
# Закінчується рядок із потрібними символами?
print(my_string.endswith('ex.')) # виведе: True
# Всі літери в нижньому регістрі
my_string = 'better than complex.'
print(my_string.islower()) # виведе: True
# Всі літери у верхньому регістрі
print('SIMPLE '.isupper()) # виведе: True
# Перший символ у верхньому, а решта у нижньому регістрі?
my_string = 'Simple'
print(my_string.istitle()) # виведе: True

# zfill() заповнює рядки зліва нулями до вказаної ширини
string = "23"
a = string.zfill(10)
print ("str.zfill : ", a) # виведе: str.zfill :  0000000023
# Якщо розмір рядка більший, ніж зазначено у методі, тоді нічого не додається
print ('112345678912121'.zfill(10)) # виведе: 112345678912121
print()

# Форматування рядків.
# Найпростіший варіант - конкатенація рядків
my_string = "Привіт "
name = "Алекс"
print(my_string + name + '!') # виведе: Привіт Алекс!

# Форматування за допомогою %
# Форматування за допомогою % - це спосіб вставляти значення в рядок за допомогою спеціальних плейсхолдерів, які починаються з символу %. Цей спосіб форматування базується на функції printf() мови C і дозволяє контролювати вигляд виводу, такий як ширина поля, кількість знаків після коми, тип даних тощо
# Створюємо змінні з різними типами даних
name = "Alice"
age = 25
height = 1.68
# Використовуємо плейсхолдери %s для рядків, %d для цілих чисел і %f для дробних чисел
s = "%s is %d years old and %f meters tall" % (name, age, height) # підставляємо замість % якісь значення
# Виводимо отриманий рядок
print(s) # виведе: Alice is 25 years old and 1.680000 meters tall

# Зауважте, що після плейсхолдера %f виводиться шість знаків після коми за замовчуванням. Якщо ви хочете змінити це, ви можете вказати кількість знаків після коми після крапки, наприклад, %.2f.
# Наприклад:
# Створюємо змінні з різними типами даних
name = "Alice"
age = 25
height = 1.68

# Використовуємо плейсхолдер %.2f для дробного числа з двома знаками після коми
s = "%s is %d years old and %.2f meters tall" % (name, age, height)

# Виводимо отриманий рядок
print(s) # виведе: Alice is 25 years old and 1.68 meters tall

# Метод format()
# Метод format() дозволяє форматувати рядки, вставляючи значення змінних або виразів в певні місця. Для цього в рядку формату потрібно використовувати фігурні дужки { }, в які можна передати індекс, ім'я або ключове слово аргументу, який буде вставлений. Також можна задавати специфікацію формату, щоб контролювати вигляд вставленого значення, наприклад, вирівнювання, ширину, точність, тип і т.д. Ось деякі приклади використання методу format():
tmplt = "Hello, I am {0}. And my name is {0}" #У фігурних дужках можна вказувати місце розташування потрібного аргументу
text = tmplt.format("Alexander")
print(text) # виведе:  Hello, I am Alexander. And my name is Alexander
print()

# f-рядки
# f-рядки - це форматовані рядкові літерали, які дозволяють вставляти значення змінних або виразів безпосередньо в рядок. Вони починаються з літери f перед одинарними або подвійними лапками. Всередині рядка можна використовувати фігурні дужки { }, в які можна передати будь-який вираз Python, який буде замінений своїм значенням. f-рядки є швидшими, зручнішими і читабельнішими, ніж інші способи форматування рядків, такі як метод format() або оператор %
# Ось деякі приклади використання f-рядків:
# Вставка значень змінних
name = "Алекс"
age = 25
my_string = f"Привіт {name.upper()} {age}!" # f - це вже показник f-рядка. Можна в {} створювати якісь змінні
print(my_string) # виведе: Привіт Алекс!

# Виклик функцій або методів
name_1 = "Ана"
name_2 = "Влад"
my_string = f"Привіт {name.upper()}, {name_1 + name_2}, {name_2.lower()}!"
print(my_string) # виведе: Привіт АЛЕКС, АнаВлад, влад!

# Використання специфікації формату
import math
print(math.pi)  # виведе: 3.141592653589793
text = "Pi = {:.4f}".format(math.pi) # .4f до 4 символів включно
print(text) # виведе: Pi = 3.1416
print(f"Число {42:b} у двійковій системі.")  # виведе: Число 101010 у двійковій системі
print()

# Що таке ASCII або UTF-8 код символу?
# Кожен символ має свій код. Справа в тому, що комп'ютер нічого не знає про символи, які ми використовуємо для письма. І для того, щоб навчити ПК нашим символам, пішли на наступний крок: кожному символу поставили у відповідність цифру, яка є його кодом. Тож з погляду ПК наш текст – це послідовність цифр. Перша така таблиця з відповідністю символу та числа, яке йому відповідає, називалася кодом символів ASCII (American Standard Code for Information Interchange). Однак, з часом, вона була замінена на UTF кодування.
# Функція ord() - це вбудована функція, яка повертає ціле число, що відповідає кодовій точці UTF-8 для даного символу. Це означає, що кожен символ має певне ціле значення, яке визначає його ідентифікацію в системі UTF-8
# Функція ord() приймає один аргумент, який повинен бути рядком довжиною один символ, наприклад, ord('A') або ord('а'). Якщо аргумент не є рядком довжиною один символ, функція ord() викине виняток TypeError.
# Функція ord() може бути корисною для отримання числового представлення символу, перевірки його типу (наприклад, літера, цифра, знак пунктуації тощо), порівняння символів за їхнім порядком, конвертації символів в бінарний або шістнадцятковий формат тощо
print(ord('a')) # виведе: 97
print(ord('F')) # виведе: 70
print(ord('\n')) # виведе: 10
print(ord('I')) # виведе: 73
print(ord('І')) # виведе: 1030 тому що ця літера відноситься до українського алфавіту

# Функція chr() - це вбудована функція, яка повертає рядок довжиною один символ, який відповідає заданій кодовій точці UTF-8l. Кодова точка - це ціле число у діапазоні від 0 до 0x10FFFF (приблизно 1,1 мільйона значень), яке визначає певний символ. Наприклад, кодова точка для символу 'A' дорівнює 65.
# Функція chr() приймає один аргумент, який повинен бути цілим числом, що представляє кодову точку UTF-8. Якщо аргумент не є цілим числом або не належить діапазону від 0 до 0x10FFFF, функція chr() викине виняток ValueError.
# Функція chr() може бути корисною для конвертації числових значень в символи, створення рядків з односимвольних рядків UTF-8, генерації різних типів символів, таких як літери, цифри, знаки пунктуації, емодзі тощо.
# ТОБТО ПРОСТО НАВПАКИ:
print(chr(1040)) # виведе: А (укр літера)
print(chr(65)) # виведе: A (літера А англійська)