# Байти
# Байти в Пайтон оголошуються за допомогою префікса b перед рядком літералів, наприклад, b'hello'
# Байти можуть містити лише значення в діапазоні від 0 до 255, які відповідають одному байту. Байти можна конвертувати в рядки за допомогою методу decode(), який приймає кодування, наприклад, 'utf-8'. Байти зазвичай використовуються для роботи з двійковими файлами, мережами, криптографією тощо.
# !!! На відміну від байтів, рядки можуть містити будь-які символи Unicode, які можуть займати від 1 до 4 байтів.
# !!! Різниця між байтами та рядками в Пайтон полягає в тому, що байти - це послідовності чисел, які представляють двійкові дані, а рядки - це послідовності символів, які представляють текстову інформацію.
# Метод encode() в Пайтон потрібен для того, щоб перетворити рядок в байти, тобто послідовність чисел, які можна зберігати або передавати в інші системи. Метод encode() приймає два параметри: кодування та спосіб обробки помилок. Кодування - це правило, за яким кожен символ рядка відповідає певному числу. Наприклад, кодування UTF-8 використовує від 1 до 4 байтів для представлення будь-якого символу Unicode. Спосіб обробки помилок - це дія, яку потрібно виконати, якщо символ не може бути закодований за даним кодуванням. Наприклад, спосіб 'ignore' просто пропускає такий символ, а спосіб 'replace' замінює його на спеціальний символ '?'
# Ось приклад різниці між байтами та рядками в Пайтон:
# Створюємо рядок з українськими символами
s = "Привіт, світ!"

# Виводимо тип та довжину рядка
print(type(s)) # виведе: <class 'str'>
print(len(s)) # виведе: 11 (від 0, пропускаємо пробіл)

# Кодуємо рядок в байти за допомогою кодування UTF-8 (В UTF-8)
b = s.encode("utf-8")

# Виводимо тип та довжину байтів
print(type(b)) # виведе: <class 'bytes'>
print(len(b)) # виведе: 19
print(b) # виведе: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd1\x96\xd1\x82, \xd1\x81\xd0\xb2\xd1\x96\xd1\x82!'

# Декодуємо байти назад в рядок за допомогою кодування UTF-8 (З UTF-8)
s = b.decode("utf-8")

# Виводимо тип та довжину рядка
print(type(s)) # виведе: <class 'str'>
print(len(s)) # виведе: 11
print(s) # виведе: Привіт, світ!

# Якщо вказати неправильне кодування, то отримаємо кракозябри
print(b.decode('windows-1251'))  # виведе: РџСЂРёРІС–С‚, СЃРІС–С‚!
# Зауважте, що довжина рядка та байтів не однакова, оскільки деякі символи Unicode займають більше одного байта !!!
print()

# Кортежі (tuple)
# Кортеж (tuple) - це незмінний тип даних !!!
# дозволяє зберігати кілька елементів у впорядкованому і не змінному вигляді. Кортеж схожий на список, але відрізняється тим, що його елементи не можна додавати, видаляти або змінювати. Кортежи можуть містити елементи різних типів, таких як числа, рядки, списки, словники тощо. Кортежи створюються за допомогою круглих дужок () або просто розділення елементів комами.
# Кортежи використовуються для таких цілей, як: !!!
# Захист даних від випадкових або навмисних змін;
# Економія пам'яті, оскільки кортежі займають менше місця, ніж списки;
# Використання в якості ключів словників, оскільки кортежі є хешованими типами даних;
# Передача даних між функціями або модулями;
# Зміна значень двох змінних одним рядком коду.
# Ось приклади роботи з кортежами:
# Створюємо кортеж з трьох елементів
t = (1, "hello", [3, 4, 5])

# Виводимо тип та довжину кортежу
print(type(t)) # виведе: <class 'tuple'>
print(len(t)) # виведе: 3

# Отримуємо доступ до елементів кортежу за індексом
print(t[0]) # виведе: 1
print(t[1]) # виведе: hello
print(t[2]) # виведе: [3, 4, 5]

# Спробуємо змінити елемент кортежу
# t[0] = 2 # викине виняток TypeError: 'tuple' object does not support item assignment

# Створюємо кортеж з одного елементу
t = (42,) # необхідна кома, інакше буде ціле число
print(type(t)) # виведе: <class 'tuple'>

t = (6) # без коми в дужках - це буде ціле число
print(type(t)) # виведе: <class 'int'>

# Створюємо кортеж без дужок
t = 1, 2, 3
print(type(t)) # виведе: <class 'tuple'>

# Створюємо кортеж з іншого ітерованого об'єкта
t = tuple("hello")
print(t) # виведе: ('h', 'e', 'l', 'l', 'o')

# Змінюємо значення двох змінних за допомогою кортежу
a = 10
b = 20
a, b = b, a # еквівалентно (a --> b(20)), (b --> a(10))
print(a) # виведе: 20
print(b) # виведе: 10

# Оскільки кортеж, незмінна структура, то й місця він займає менше, у порівнянні зі списком
import sys
lst = [10, 20, 30]
tpl = tuple(lst) # from list to tuple

print(sys.getsizeof(lst)) # виведе: 88
print(sys.getsizeof(tpl)) # виведе: 64
# sys.getsizeof() - повертає розмір об'єкта в байтах

# Сума двох кортежів створює новий кортеж
t1 = (42,)
t2 = (10, 20, 30)
tpl = t1 + t2
print(tpl) # виведе: (42, 10, 20, 30)
tpl = t2 + t1
print(tpl) # виведе: (10, 20, 30, 42)

# Доступ до елементів кортежу такий самий, як і у списку
a = (1, 2, 3, 4, 5)

print(a[0]) # виведе: 1
print(a[1:3]) # виведе: (2, 3)
print(a[-1]) # виведе: 5

# Якщо елемент кортежу, це вказівник на структуру даних, що змінюється, то можуть бути “сюрпризи”
lst = ['a', 'b']
my_tuple = (1, 2, lst, 4, 5)
print(my_tuple) # виведе: (1, 2, ['a', 'b'], 4, 5)

my_tuple[2][1] = 999 # змінюємо елемент списка
print(my_tuple) # виведе: (1, 2, ['a', 999], 4, 5)
# !!! У самому кортежі нічого не змінилося - кількість елементів, і самі елементи залишилися незмінними. Зміни відбулися у списку, який є частиною кортежу. Але при цьому кортеж залишився незмінним.

# Оскільки кортеж, це незмінна структура, то й методи, які є у кортежу тільки ті, які повертають результат, не змінюючи сам кортеж
my_tuple = ('a', 'p', 'p', 'l', 'e',)

print(my_tuple.count('p')) # виведе: 2
print(my_tuple.index('l')) # виведе: 3

print('a' in my_tuple) # виведе: True
print('b' in my_tuple) # виведе: False
print()

# Словники
# Словники – це вбудований тип даних, який є асоціативним масивом або хешем і базується на відображенні пар типу (ключ: значення)
# Словники - змінюванний тип данних !!!
# Ключ - 1 значення !!!
# Списки, словники, set`ы - змінюються !!!
#
# Переваги застосування словників: !!!
# з допомогою словників можна розробляти ефективні структури даних;
# для словників не потрібно писати вручну алгоритми пошуку даних, оскільки ці операції вже є реалізовані;
# словники можуть містити об’єднані дані у вигляді записів;
# словники ефективні при представленні розріджених структур даних.
#
# Основні характеристики словників наступні: !!!
# у словниках доступ до елементів виконується за ключем, а не за індексом. Словники визначають взаємозв’язок пар ключ-значення. За ключем відбувається доступ до значення. Якщо у словнику реалізовувати доступ до значення за індексом, то в цьому випадку індекс представляє собою ключ, а не зміщення відносно початку;
# словники представляють невпорядковані колекції довільних об’єктів. У словниках елементи (ключі) зберігаються у невизначеному порядку. Порядок формування елементів у словнику визначає інтерпретатор. Це необхідно для забезпечення більш швидкого пошуку.
# словники мають змінну довжину. Кількість елементів у словнику може збільшуватись або зменшуватись;
# гетерогенність – словники можуть містити об’єкти будь-яких типів;
# довільна кількість вкладень – словники мають можливість створення довільної кількості рівнів вкладень, оскільки словники можуть містити списки, інші словники тощо;
# словники відносяться до категорії змінюваних об’єктів. Тому, у словниках немає сенсу використовувати операції які мають фіксований порядок слідування елементів (наприклад, конкатенація);
# словники є таблицями посилань на об’єкти або хеш-таблицями і відносяться до об’єктів-відображень. Це означає, що у словниках об’єкти відображають (представляють) ключі на значення.
#
# Між словниками і списками існують наступні основні відмінності:
# списки є впорядкованими колекціями, словники не є впорядкованими колекціями;
# у списках елементи витягуються з допомогою зміщення, яке визначає позицію елементу в списку. У словниках елементи витягуються за допомогою ключа;
# на відміну від списків у словниках немає підтримки операцій над послідовностями (наприклад, конкатенація, витягування зрізу та інше);
# списки є масивами посилань на об’єкти. Словники є масивами невпорядкованих таблиць посилань на об’єкти, які підтримують доступ до об’єктів за ключем.
# Ось приклад створення та використання словника в Пайтон:
# 1. Пустий словник
d1 = dict()
print(type(d1)) # виведе: <class 'dict'>

d2 = {}
print(type(d2)) # виведе: <class 'dict'>

# Створюємо словник з трьох елементів
d = {"name": "Alice", "age": 25, "hobbies": ["reading", "writing", "coding"]}

# Виводимо тип та довжину словника
print(type(d)) # виведе: <class 'dict'>
print(len(d)) # виведе: 3

# Отримуємо доступ до елементів словника за ключем
print(d["name"]) # виведе: Alice
print(d["age"]) # виведе: 25
print(d["hobbies"]) # виведе: ['reading', 'writing', 'coding']

# Змінюємо значення за ключем
d["age"] = 26
print(d["age"]) # виведе: 26

# Додаємо новий елемент до словника
d["city"] = "London"
print(d) # виведе: {'name': 'Alice', 'age': 26, 'hobbies': ['reading', 'writing', 'coding'], 'city': 'London'}


# Створення словника з допомогою конструктора dict
SEASONS = dict(Winter=1, Spring=2, Summer=3, Autumn=4)
print(SEASONS) # виведе: {'Winter': 1, 'Spring': 2, 'Summer': 3, 'Autumn': 4}

# Створення словника, із заздалегідь заданого набору ключ-значення
pairs = [('IBM', 125), ('ACME', 50), ('PHP', 40)]
d = dict(pairs)
print(d) # виведе: {'IBM': 125, 'ACME': 50, 'PHP': 40}

# Як перевірити наявність ключа у словнику? Це можна зробити за допомогою оператора in
d = {'IBM': 125, 'ACME': 50, 'PHP': 40}

print("IBM" in d) # виведе: True
print("Iva" in d) # виведе: False
print()

# Які значення можуть використовуватись в якості ключів?
# В якості ключів не можна використовувати змінювані типи об’єктів !!!
# Наприклад, списки, словники та інші змінювані типи не можуть використовуватись в якості ключів. Однак, в якості значень ці змінювані типи можна використовувати. Тобто в якості ключа може бути тільки тип даних що не змінюється. Він ще має назву - тип даних, що хешується

# Що таке тип даних, що хешується?
# Тип даних, що хешується в Пайтон, - це тип даних, який має функцію хешування, яка повертає ціле число, що ідентифікує значення об'єкта
# Хешування - це процес перетворення даних будь-якої довжини в даних фіксованої довжини, які можна швидко порівнювати та шукати
# Типи даних, що хешуються, використовуються в якості ключів словників або елементів множин, оскільки вони дозволяють ефективно здійснювати операції доступу, додавання, видалення та перевірки належності.
# Приклади типів даних, що хешуються в Пайтон, - це цілі числа, дійсні числа, комплексні числа, рядки, кортежі, тощо.
# Хеш (він же хеш-код) — це зазвичай число, яке генерується на підставі вмісту об'єкта за допомогою функції згортки.
# Функція hash - це вбудована функція, яка повертає ціле число, що ідентифікує значення об'єкта
# Функція hash використовується для створення хеш-таблиць, які дозволяють швидко знаходити, додавати, видаляти або перевіряти елементи за допомогою ключів. Функція hash приймає один аргумент, який повинен бути типом даних, що хешується, наприклад, цілим числом, рядком, кортежем тощо. Якщо аргумент не є типом даних, що хешується, функція hash викине виняток TypeError.
print(hash(10)) # Хеш від числа, зазвичай повертає те саме число

print(hash('10')) # можливий варіант: 2495007945438691198
print(hash('Hello world')) # можливий варіант 7294899485977359521
print(hash((1, 5))) # можливий варіант 173794974761290439

# Чому у коментарі зазначено –можливий варіант? Справа в тому, що функція хеш використовує додаткові параметри, які є унікальними для кожного запуску інтерпретатора. Тому у Вас значення можуть бути іншими. Головне, що в межах одного сеансу, функція хеш буде повертати те саме значення, для однакових даних, не залежно від кількості запитів.
# Хеш недоступний для типу даних, що змінюється
# print(hash([1, 5])) # TypeError: unhashable type: 'list'
print()

# Вкладені структури
# Так само як і в списках, де елементом списку може бути інший список (вкладена структура), у словниках як значення може бути також словник
human = {"name": "Alexander",
        "lastname": "Glock",
        "age": 36,
        "address": {"street": "Lisova", "house": 87, "flat": 705}
}

house = human["address"]["house"] # звертаємось до словника, ключа і значення
print(house) # виведе: 87

# Міняємо значення для квартири
human["address"]["flat"] = 700
print(human["address"]["flat"]) # виведе: 700
print()
# Доступ до елементів вкладеної структури в словниках здійснюється так само, як і в списках, тільки замість індексів, ми вказуємо ключі.

# Методи словників
# copy() - повертає копію словника.
# Якщо значення словника, це незмінний тип даних, то копія не впливатиме на оригінал.
d2 = {"A1":"123", "A2":"456"}
d3 = d2.copy()

d3["A1"] = 10
print(d2) # виведе: {'A1': '123', 'A2': '456'}
print(d3) # виведе: {'A1': 10, 'A2': '456'}
# Але проблеми виникають, коли значення - це тип даних, що змінюється:
d2 = {"A1": {1: "one", 5: "five"}, "A2":"456"}
d3 = d2.copy()

d3["A1"][1] = 1
print('d2 ->', d2) # виведе: d2 -> {'A1': {1: 1, 5: 'five'}, 'A2': '456'}
print('d3 ->', d3) # виведе: d3 -> {'A1': {1: 1, 5: 'five'}, 'A2': '456'}
# Створилась не глибока копія,

# Обидва елементи різних словників, посилаються на ту саму адресу пам'яті
print(id(d2["A1"]) == id(d3["A1"])) # виведе: True

# Щоб уникнути подібних проблем, потрібно щоб між копіями був повний розрив, у тому числі і по елементах
import copy

d2 = {"A1":{1: "one", 5: "five"}, "A2":"456"}
d3 = copy.deepcopy(d2)

d3["A1"][1] = "789"
print('d2 ->', d2) # виведе: d2 -> {'A1': {1: 'one', 5: 'five'}, 'A2': '456'}
print('d3 ->', d3) # виведе: d3 -> {'A1': {1: '789', 5: 'five'}, 'A2': '456'}
print(id(d2["A1"]) == id(d3["A1"])) # виведе: False

# fromkeys(seq[, value]) - створює словник з ключами seq і значенням value (за замовчуванням None)
# використання методу з налаштуваннями за замовчуванням
my_new_dict = dict.fromkeys(['one', 'two', 3])
print(my_new_dict) # виведе: {'one': None, 'two': None, 3: None}

ooo = [1, "d43", 32, 1, 1]
x = dict.fromkeys(ooo, 1)
print(x) # {1: 1, 'd43': 1, 32: 1}, дублікати видаляються

# вкажемо значення за замовчуванням
my_new_dict = dict.fromkeys(['one', 'two', 3], 10)
print(my_new_dict) # виведе: {'one': 10, 'two': 10, 3: 10}

# Невдалий варіант ініціалізувати всі елементи змінними даними
my_new_dict = dict.fromkeys([1, 2, 3], [])
print(my_new_dict) # виведе: {1: [], 2: [], 3: []}

# Додамо значення до списку із ключем 1
my_new_dict[1].append('add')
print(my_new_dict) # виведе: {1: ['add'], 2: ['add'], 3: ['add']}

# значення для всіх ключів вказують на той самий список
print(id(my_new_dict[1]) == id(my_new_dict[2]) == id(my_new_dict[3]))  # виведе: True

# Щоб уникнути цієї проблеми, потрібно відмовитися від використання методу fromkeys, а використовувати створення таких структур за допомогою циклу:
my_new_dict = {}
for key in [1, 2, 3]:
    my_new_dict[key] =  []

my_new_dict[1].append('add')
print(my_new_dict) # виведе: {1: ['add'], 2: [], 3: []}

# Або за допомогою генераторного виразу
my_new_dict = {key: [] for key in [1, 2, 3] }

my_new_dict[1].append('add')
print(my_new_dict) # виведе: {1: ['add'], 2: [], 3: []}

# get(key) - повертає значення ключа
# При роботі з словниками можлива ситуація, коли відбувається доступ за ключем, якого немає в словнику. У цьому випадку в програмі виникає помилка і генерується виключення KeyErro
# Щоб уникнути помилки доступу за неіснуючим ключем можна попередньо перевірити наявність ключа з допомогою конструкції if, або використати метод get(), який, у випадку неіснуючого ключа, повертає дефольне значення **(**за замовчуванням None).
# Помилка, якщо немає такого ключа
# d2 = {"A1":{1: "one", 5: "five"}, "A2":"456"}
# d2[4] # KeyError: 4

#Помилки немає, для відсутнього ключа
print(d2.get(4)) # виведе: None

# Можна встановити значення за замовчуванням для ключа, який відсутній
print(d2.get('address', {}))
print(d2) # виведе: {}

#isinstance - перевіряє, чи є об'єкт (object) екземпляром певного класу (classinfo) чи його підкласу. Вона повертає True, якщо об'єкт відповідає зазначеному типу (або одному з типів у кортежі), і False інакше.

# items() - повертає набір пар (ключ, значення)
# Цей набір дуже схожий на список, але при цьому списком не є !!!
student = {"name": "Alexander", "lastname": "Tsin", "age": 36, "group": "PN121"}
# Результат роботи цього методу схожий на список, але таким не є
print(student.items()) # виведе: dict_items([('name', 'Alexander'), ('lastname', 'Tsin'), ('age', 36), ('group', 'PN121')])
# У цього типу даних немає можливості звертатися до елементів за індексом
# lst = student.items()
# lst[0]  # TypeError: 'dict_items' object is not subscriptable
# Щоб мати змогу працювати з цим об'єктом, як зі списком, його необхідно перетворити до списку у явному вигляді:
lst = list(student.items())
print(lst[0]) # виведе: ('name', 'Alexander')

# Найчастіше, результат цього методу використовується як об'єкт для ітерації в циклі
for key, val in student.items():
    print(f'Key: {key}, value: {val}')
# виведе:
# Key: name, value: Alexander
# Key: lastname, value: Tsin
# Key: age, value: 36
# Key: group, value: PN121

# values() - повертає набір значень словника (виводить тільки значення)
# Це теж спископодібний об'єкт, як і для keys(). Дії аналогічні
student = {"name": "Alexander", "lastname": "Tsin", "age": 36, "group": "PN121"}
print(student.values()) # виведе: dict_values(['Alexander', 'Tsin', 36, 'PN121'])

# У такий спосіб можна перевірити наявність елемента серед значень словника
print('Alexander' in student.values()) # виведе: True

# pop(key[, default]) - видаляє пару ключ/значення зі словника і повертає значення як результат своєї роботи
d = {"A1":"123", "A2":"456"}
a = d.pop("A1")

print(d) # виведе: {'A2': '456'}
print(a) # виведе: 123

# Якщо такого ключа немає, то буде помилка
# a = d.pop("A1") # KeyError: 'A1'

# Щоб не було помилки для відсутнього ключа, можна вказати значення за замовчуванням
a = d.pop("A1", [])
print(a) # виведе: []

# popitem() - видаляє та повертає пару (ключ, значення).
d = {"A2":"456"}
k, v = d.popitem()
print(k, v)  # виведе: A2 456
print(d)  # виведе: {}

# Якщо словник порожній, викидає KeyError.
# k, v = d.popitem()  # KeyError: 'popitem(): dictionary is empty'

# setdefault(key[, default]) - створює у словнику ключ із переданим значенням default (за замовчуванням None), якщо такого ключа у словнику немає. Якщо такий ключ є – нічого не робить.
# Приклад для пояснення. Необхідно порахувати кількість повторень кожного числа у списку
dict_one = {}
lst = [1, 2, 3, 6, 3, 1, 7]
for i in lst:
    # пробуємо отримати значення для ключа
    count = dict_one.get(i) # повертає або число, або None
    if count:
        # якщо значення є, збільшуємо на 1
        dict_one[i] = count + 1
    else:
        # якщо значення немає, встановлюємо початкове
        dict_one[i] = 1
#словник, у якому ключами є елементи списку, а значеннями те, скільки разів вони зустрічалися у списку
print(dict_one)  # виведе: {1: 2, 2: 1, 3: 2, 6: 1, 7: 1}

# Вирішимо те саме завдання, але вже з використанням методу setdefault
dict_one = {}
l = [1, 2, 3, 6, 3, 1, 7]
for i in l:
    # для заданого ключа, встановлюємо значення 0
    dict_one.setdefault(i, 0) # спрацює у разі, якщо такого ключа ще немає
    # тепер можемо змінювати значення за ключем, оскільки у словнику він вже точно є
    dict_one[i] = dict_one[i] + 1

print(dict_one)
print()
# update([other]) - оновлює словник, додаючи пари (ключ, значення) з other.

# OrderedDict
# OrderedDict - це підклас словника, який зберігає порядок, в якому ключі були додані вперше
# Єдина різниця між dict() та OrderedDict() полягає в тому, як вони обробляють порядок ключів в Пайтон: !!!
# OrderedDict зберігає послідовність, в якій ключі були додані, гарантуючи, що порядок зберігається під час ітерації. А також є можливість переміщати ключі у словнику та видаляти пару (ключ/значення) не тільки з кінця, але і з початку словника.
from   collections import OrderedDict
dct = OrderedDict({'apple': 4, 'banana': 3, 'orange': 2, 'pear': 1})
print(dct)  # виведе: OrderedDict({'apple': 4, 'banana': 3, 'orange': 2, 'pear': 1})
print(len(dct)) # виведе: 4

# Методи в основному як і у звичайного словника, але є кілька особливих

# popitem(last=True) - видаляє останній елемент якщо last=True, і перший, якщо last = False.
print(dct.popitem())  # виведе: ('pear', 1), тобто останній (last=True за замовченням)
print(dct.popitem(last=False))  # виведе: ('apple', 4)
print(dct)  # виведе: OrderedDict({'banana': 3, 'orange': 2})
dct2 = OrderedDict({'apple': 4, 'banana': 3, 'orange': 2, 'pear': 1, 'pineapple': 3})
print(dct2.popitem())
print(dct2.popitem(last=False))
print(dct2) # виведе: OrderedDict({'banana': 3, 'orange': 2, 'pear': 1})

# move_to_end(key, last=True) - переміщає ключ у кінець якщо last=True, і початок, якщо last=False.
dct['apple'] = 4
print(dct)  # виведе: OrderedDict({'banana': 3, 'orange': 2, 'apple': 4})

dct.move_to_end('banana')
# ключ banana став останнім
print(dct)  # виведе: OrderedDict({'orange': 2, 'apple': 4, 'banana': 3}),  в кінець, бо за замовчуванням last=True

# ключ apple став першим
dct.move_to_end('apple', last=False)
print(dct)  # виведе: OrderedDict({'apple': 4, 'orange': 2, 'banana': 3})
print()

# defaultdict
# defaultdict - це підклас словника, який автоматично створює значення за замовчуванням для ключів, які не існують у словнику
# Це дозволяє уникнути винятку KeyError, коли ви намагаєтеся отримати доступ або змінити значення за відсутнім ключем
# defaultdict приймає один аргумент, який є функцією, що повертає значення за замовчуванням для будь-якого ключа !!!
from collections import defaultdict
defdict = defaultdict(list)
# Тепер при додаванні будь-якого ключа до словника, значення цього ключа буде порожній список

# Отримуємо значення за відсутнім ключем
print(defdict["d"]) # виведе: []

# Оскільки ми знаємо, що за будь-яким ключем буде список, ми можемо використовувати методи властиві спискам
for i in range(5):
    defdict[i].append(i * 5) # спочатку буде 0 * 5, потім 1 * 5, 2 * 5, і так до 4 * 5, бо 5 не включно

print(defdict) # виведе: defaultdict(<class 'list'>, {0: [0], 1: [5], 2: [10], 3: [15], 4: [20]})
# Створюємо defaultdict, який повертає 0 для будь-якого ключа
dct = defaultdict(lambda: 0)
# !!! lambda - ключове слово для створення анонімних, або "безіменних", функцій. Вони призначені для простих, коротких операцій і можуть містити лише одне вираження
# Синтаксис: lambda arguments: expression
# Вираження: Вираз виконується і його результат повертається як значення функції.
# Приклад: sum_lambda = lambda x, y: x + y створить лямбда-функцію, яка повертає суму двох аргументів x та y
print(dct["d"]) # виведе: 0
print()

# namedtuple
# namedtuple - це функція, яка дозволяє створювати підкласи кортежів з іменованими полями
# Ви можете отримувати доступ до значень в даному іменованому кортежі, використовуючи крапкову нотацію та імена полів
# Також namedtuple дозволяє не лише зберігати кілька значень, але й звертатися до них за іменами, а не тільки за індексами !!!
# Він був створений для покращення читабельності коду, надаючи спосіб доступу до значень, використовуючи описові імена полів , замість цілочисельних індексів, які більшість часу не дають жодної інформації про те, що представляють значення
# Для створення іменованого кортежу, потрібно задати ім'я класу та список імен полів. Наприклад:
from collections import namedtuple

# Створюємо іменований кортеж Point з двома полями x та y
Point = namedtuple('Point', 'x y')

# Створюємо екземпляр Point з координатами (1, 2)
p = Point(1, 2)

# Отримуємо доступ до значень за іменами полів
print(p.x) # виведе: 1
print(p.y) # виведе: 2

# Доступ до значень також можна отримати через індекси
print(p[0]) # виведе: 1
print(p[1]) # виведе: 2

# Тобто якщо було б: namedtuple('Point', 'x y z')
# p = Point(1, 2, 3)
# то спрацювало б: p.z = 3

# В іменованому кортежі, як і в звичайному, не можна змінювати значення
# p[0] = 4  # TypeError: 'Point' object does not support item assignment
