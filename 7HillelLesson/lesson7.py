# OrderedDict
# OrderedDict зберігає порядок додавання елементів, що важливо для деяких випадків
# Вона є покращеною версією стандартного словника (dict) в мові програмування Python
# Основна особливість полягає в тому, що він зберігає порядок додавання елементів
# У звичайному словнику порядок елементів не гарантується, але у випадку OrderedDict елементи зберігаються у тому порядку, в якому їх додано
# Створення OrderedDict:
from collections import OrderedDict

ordered_dict = OrderedDict()

# Додавання елементів:
ordered_dict['a'] = 1
ordered_dict['b'] = 2
# У вказаному прикладі елемент 'a' буде першим у впорядкованому словнику, а 'b' - другим

# Доступ до елементів:
value_of_a = ordered_dict['a']
value_of_b = ordered_dict['b']
print(value_of_a)  # Виведе 1
print(value_of_b)  # Виведе 2

# Зміна значень:
ordered_dict['a'] = 100
print(ordered_dict)  # Виведе OrderedDict([('a', 100), ('b', 2)])

# Видалення елемента:
del ordered_dict['a']
print(ordered_dict)  # Виведе OrderedDict([('b', 2)])

# Перевірка наявності ключа:
if 'a' in ordered_dict:
    print("Key 'a' is present.")
else:
    print("Key 'a' is not present.")

# Збереження порядку:
ordered_dict['c'] = 3
print(ordered_dict)  # Виведе OrderedDict([('b', 2), ('c', 3)])
# У випадку звичайного словника не гарантується, що 'c' буде останнім елементом, але в OrderedDict порядок зберігається
# OrderedDict є корисним, коли потрібно контролювати порядок елементів у словнику
# Він може бути особливо важливим у випадках, коли порядок додавання даних має значення, наприклад, при обробці та зберіганні конфігурацій чи інших послідовностей
print()

# Іменований кортеж (namedtuple)
# Іменовані кортежі є підкласом звичайних кортежів, які дозволяють створювати кортежі з іменованими полями
# Вони предоставляють читабельні та іменовані поля, що полегшує доступ до даних в кортежі

# Створення іменованого кортежу:
from collections import namedtuple

# Створення іменованого кортежу з іменованими полями 'name' та 'age'
Person = namedtuple('Person', ['name', 'age', 'address'])
# У вказаному прикладі Person - це іменований кортеж, який має два поля: 'name' та 'age'.

# Створення екземпляра іменованого кортежу:
person1 = Person(name='John', age=25, address="New York")
person2 = Person(name='Alex', age=27, address="Miami")
# В цьому випадку створюється екземпляр іменованого кортежу зі значеннями 'John' та 25 для полів 'name' та 'age' відповідно
# Доступ до значень за допомогою іменованих полів:
print(person1.name)  # Виведе 'John'
print(person1.age)   # Виведе 25
print(person2.name)  # Виведе 'Alex'
print(person2.age)   # Виведе 27
print(person2.address, person2.age) # Miami 27
print(f"Hello, my name is: {person1.name}! Im from {person2.address}")  # Hello, my name is: John! Im from Miami
# Іменовані кортежі роблять код більш зрозумілим, оскільки можна звертатися до полів за їхніми іменами, що полегшує читання та розуміння коду

# Зміна значень:
# Створення нового екземпляру зі зміненим значенням 'age' за допомогою replace !!!
updated_person = person1._replace(age=30)
print(updated_person)  # Виведе Person(name='John', age=30)
# Іменовані кортежі є невимірно корисним інструментом в ситуаціях, коли потрібно представляти дані з іменованими атрибутами, але при цьому зберігати їх у не змінюваній структурі даних, яка схожа на кортеж
print()

# Множина (set)
# Множина є колекцією унікальних елементів без порядку. Вона використовується для зберігання неповторюваних значень

# Створення множини:
my_set = {1, 2, 5, "hello", "world"}
# Якщо робити ключ+значення, то потрібно тоді усім ключам дати значення, а не тільки, наприклад: 1: 43. Потрібно усім дати значення !!!
print(my_set) # {1, 2, 5, 'hello', 'world'}
print(type(my_set)) # <class 'set'>
# Множина не терпить дублікати !!!
my_set1 = {1, 3, 3, 5}
print(my_set1) # {1, 3, 5}

# Множини у Python підтримують різні методи для виконання операцій над ними. Давайте розглянемо деякі з найважливіших методів:

# add(): Додає елемент до множини
my_set = {1, 2, 3}
my_set.add(4)
print(my_set) # {1, 2, 3, 4}

# remove(): Видаляє вказаний елемент з множини. Генерує виняток, якщо елемент відсутній
my_set = {1, 2, 3}
my_set.remove(2)
print(my_set) # {1, 3}
# my_set = {1, 3}
# my_set.remove(2)
# print(my_set) # KeyError: 2

# discard(): Видаляє вказаний елемент з множини, якщо він присутній. Не генерує виняток, якщо елемент відсутній
my_set = {1, 2, 3}
my_set.discard(2)
print(my_set) # {1, 3}
my_set = {1, 3}
my_set.discard(2)
print(my_set) # {1, 3}
# Саме тому краще використовувати discard()

# pop(): Видаляє та повертає випадковий елемент з множини. Генерує виняток, якщо множина порожня
my_set = {1, 2, 3}
popped_element = my_set.pop()
print(my_set) # {2, 3}

# union(): Повертає нову множину, яка містить усі унікальні елементи обох множин
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2) # set1 - елемент, у якого викликається метод .union(), set2 - елементи якого додаються до результату
print(union_set) # {1, 2, 3, 4, 5}

# intersection(): Повертає нову множину, яка містить лише ті елементи, які є спільними для обох множин
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1.intersection(set2)
print(intersection_set) # {3} - є в обох множинах

# difference(): Повертає нову множину, яка містить елементи першої множини, які відсутні в другій
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1.difference(set2)
print(difference_set) # повертає те, що відсутнє у другій множині: {1, 2} !!!

# clear(): Видаляє всі елементи з множини, залишаючи порожню множину
my_set = {1, 2, 3}
my_set.clear()
print(my_set) # set(), нема ні яких значень
print(len(my_set)) # 0
print()

# Порівняння множин
# Методи порівняння множин дозволяють виконувати різні операції порівняння між множинами
# Давайте розглянемо кілька основних методів:
# union() (або |): Повертає нову множину, яка містить усі унікальні елементи обох вихідних множин.
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)
print(union_set) # {1, 2, 3, 4, 5}

# intersection() (або &): Повертає нову множину, яка містить лише ті елементи, які є спільними для обох вихідних множин
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1.intersection(set2)
print(intersection_set) # 3

# difference() (або ``): Повертає нову множину, яка містить елементи першої множини, які відсутні в другій
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1.difference(set2)
print(difference_set) # {1, 2}
# ТОБТО ВСЕ ТЕ Ж САМЕ
print()

# Frozenset
# Frozenset - тип данних !!!
# Frozenset є вбудованим класом в Python і представляє собою незмінну (immutable) версію множини
# Основна відмінність між frozenset та звичайною множиною в тому, що frozenset не може бути змінений після свого створення !!!
# Це означає, що до нього не можна додавати чи видаляти елементи, а отже, його можна використовувати як ключ у словнику !!!
# Приклад використання:
frozen_set = frozenset([1, 2, 3])
print(frozen_set) # frozenset({1, 2, 3})
# У цьому прикладі ми створюємо frozenset зі списку [1, 2, 3]

# Цей об'єкт frozenset може бути використаний як ключ у словнику, оскільки він є незмінним:
my_dict = {frozen_set: "Hello"}
print(my_dict) # {frozenset({1, 2, 3}): 'Hello'}
# Основна перевага frozenset полягає в його використанні в ситуаціях, де потрібно гарантувати, що множина залишається незмінною
# Наприклад, при використанні її як ключа у словнику або елемента множини в іншій множині
print()

# Функції
# Введення у світ функцій.
# У світі програмування функції відіграють ключову роль, надаючи можливість структурувати код та виконувати конкретні завдання
# !!! Функції - це блоки коду, призначені для виконання конкретних завдань. Вони дозволяють створювати повторно використовувані частини коду, що сприяє більшій структурованості та зручності обслуговування програм.
#
# Необхідність використання.
# Основні переваги використання функцій включають:
# Повторне використання коду: Функції дозволяють організувати код у відокремлені блоки, які можна викликати з різних частин програми. Це полегшує повторне використання коду та уникнення дублювання.
# Зручність обслуговування: Функції допомагають структурувати програму та зробити код більш зрозумілим. Кожна функція відповідає за конкретну функціональність, що спрощує розуміння та редагування коду.
# Підтримка модульності: Використання функцій сприяє створенню модульної програмної структури. Кожна функція може виконувати певну задачу, і їхнє використання в різних частинах програми дозволяє легко змінювати або розширювати функціональність.
# Підтримка рекурсії: Функції можуть викликати самі себе, що відкриває можливості для реалізації рекурсивних алгоритмів та розв'язання деяких завдань більш ефективним способом.
# Рекурсія в Python - це техніка, за якою функція викликає сама себе для розв'язання задачі, яка може бути розбита на менші підзадачі того самого типу
#
# Огляд концепцій та призначення функцій у програмуванні розширює можливості розробки програм та дозволяє покращувати якість та ефективність коду

# Оголошення функцій.
# Оголошення функції в Python виглядає наступним чином:
def add_numbers(a, b):
    return a + b
# У цьому прикладі ми оголошуємо функцію під назвою add_numbers, яка приймає два аргументи, a та b, і повертає їхню суму
# Оголошення функції починається з ключового слова def, за яким слідує ім'я функції та в круглих дужках перераховуються параметри (аргументи), які функція приймає
# Тіло функції визначається відступами та може містити будь-яку кількість операторів

# Оголошення функцій дозволяє створювати власні блоки коду, які можна повторно використовувати в програмі
# Це покращує структуру програми, забезпечує читабельність коду та допомагає уникнути дублювання коду

# Виклик функцій.
# Функції в Python можна викликати з інших частин програми для виконання конкретної дії або обчислення значень
# Виклик функції здійснюється за допомогою ім'я функції та передачею аргументів, які вказуються в круглих дужках
# Наприклад, для виклику функції add_numbers, оголошеної раніше, яка обчислює суму двох чисел, можна використовувати наступний код:
result = add_numbers(3, 4)
print(result) # 7
# У цьому випадку функція отримує аргументи 3 та 4, обчислює їх суму, і результат (сума, тобто 7) повертається та зберігається в змінній result
# Виклик функції може використовуватися для отримання значень, які функція повертає, або для виконання певних операцій, які функція реалізує
# Ще можна одразу викликати ф-цію в самому print`i
print(add_numbers(3, 4)) # 7

# Передача аргументів.
# При виклику функції у Python, аргументи можна передавати різними способами, що надає гнучкість при роботі з функціями
# Позиційні аргументи.
# У цьому випадку аргументи передаються в тому порядку, в якому вони оголошені у функції. Приклад:
def greet(name, greeting):
    print(f"{greeting}, {name}!")

greet("Alice", "Hello") # Hello, Alice!
# У функції greet спершу передається аргумент "Alice", а потім "Hello"
# Значення присвоюються відповідним параметрам у порядку їхнього оголошення

# Ключові аргументи.
# Тут аргументи передаються, вказуючи їхні імена. Це полегшує читання та розуміння коду, особливо коли функція має багато параметрів
def greet(name, greeting):
    print(f"{greeting}, {name}!")

greet(greeting="Hello", name="Alice") # Hello, Alice!
# У цьому випадку порядок аргументів не має значення, оскільки вони передаються за їхніми іменами

# Зі значенням за замовчуванням.
# Функція може мати аргументи зі значенням за замовчуванням, які можна використовувати, якщо значення не вказано при виклику функції
def multiply(a, b=2):
    return a * b
# У цьому прикладі, якщо аргумент b не передається при виклику, він приймає значення за замовчуванням, яке дорівнює 2
# pass - заглушка. Відповідно код пропускається всередині ф-ції

# Відповіді на питання:

# Чи збігається розмір рядка та розмір створених з нього байтів?
# Залежить від того, які символи використовувалися в рядку

# Що можна зробити за допомогою оператора in в словнику?
# Перевірити наявність ключа

# Який тип даних може бути ключем для словника?
# Незмінний тип даних

# За допомогою якого методу можна звернутися до словника за ключом якого немає і не отримати при цьому помилку?
# get

# Чи можна додавати значення ключа, якого немає у словнику?
# Так