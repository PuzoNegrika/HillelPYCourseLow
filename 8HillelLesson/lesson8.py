# Глобальні та локальні змінні.
# Глобальні змінні:
# Глобальні змінні визначаються на рівні програми і можуть бути доступні в усьому коді. Такі змінні оголошуються за межами будь-якої функції чи блоку коду
# Вони зберігають своє значення протягом усього часу виконання програми. Глобальні змінні можуть використовуватися у всіх функціях та частинах програми
# Приклад:
global_variable = 10 # це глобальна змінна

def example_function():
    print(global_variable)  # Глобальна змінна доступна всередині функції

example_function() # 10
print(global_variable)  # 10. Глобальна змінна доступна поза функцією
# У цьому прикладі global_variable є глобальною змінною, і вона може використовуватися і всередині функції example_function, і поза нею

# Локальні змінні:
# Локальні змінні визначаються всередині функцій чи блоків коду і доступні тільки в межах цих областей видимості
# Це означає, що локальні змінні не можуть бути використані за межами функцій, в яких вони оголошені
# Приклад:
def example_function():
    local_variable = 5
    print(local_variable)  # Локальна змінна доступна тільки всередині функції

example_function() # 5
#print(local_variable)  # Помилка - локальна змінна недоступна поза функцією
# У цьому прикладі local_variable є локальною змінною, і вона доступна лише всередині функції example_function
# Поза цією функцією спроба звертання до local_variable викличе помилку

# Глобальні та локальні змінні в коді
# У цьому коді global_variable - глобальна змінна, яка доступна як всередині функції, так і поза нею
# local_variable - локальна змінна, доступна лише всередині функції example_function, і спроба звертатися до неї поза цією функцією призведе до помилки
global_variable = 10

def example_function():
    local_variable = 5
    print(global_variable)  # 10. Доступ до глобальної змінної
    print(local_variable)   # 5. Локальна змінна функції

example_function()
print(global_variable)      # Глобальна змінна доступна поза функцією
#print(local_variable)      # Помилка - локальна змінна недоступна поза функцією
print()

# Передача аргументів.
# Передача аргументів в функції - це механізм, за допомогою якого значення передаються у функцію при її виклику
# У Python існують два основних типи передачі аргументів: позиційні та ключові:
# Позиційні аргументи: При передачі позиційних аргументів значення передаються у функцію у порядку, в якому вони вказані у виклику функції.
# Ключові аргументи: При передачі ключових аргументів значення передаються з вказанням імені параметра. Такий підхід дозволяє вказувати аргументи у будь-якому порядку, що робить виклик функції більш зрозумілим і гнучким.
# Приклад:
def example_function(arg1, arg2, arg3):
    print(arg1, arg2, arg3)

example_function(1, 2, 3)                    # Позиційні аргументи
example_function(arg3=3, arg1=1, arg2=2)     # Ключові аргументи
# У першому виклику example_function(1, 2, 3), аргументи передаються позиційно, тобто значення 1 прив'язується до параметра arg1, 2 - до arg2, і 3 - до arg3
# У другому виклику example_function(arg3=3, arg1=1, arg2=2), аргументи передаються ключовим чином, вказуючи імена параметрів. Порядок важливий лише в межах кожного конкретного параметра
# Обидва варіанти виклику виведуть "1 2 3" на екран
print()

# Правило доступу до змінних LEGB.
# LEGB вказує на порядок пошуку значень змінних в Python. Розглянемо кожен рівень детальніше:
# Local (локальні): Локальні змінні оголошуються всередині функції і доступні лише в межах цієї функції. Найближчий рівень !!!
def example_function():
    local_variable = 5
    print(local_variable)  # Локальна змінна

# Enclosing (обхоплюючі): Змінні, оголошені в зовнішній функції, що оточує внутрішню функцію. Ці змінні доступні внутрішній функції, але не в глобальному контексті
def outer_function():
    enclosing_variable = 10

    def inner_function():
        print(enclosing_variable)  # Обхоплююча змінна
        j = 7
        def one_more_nested():
            print("Hello from inside inner_function!")
            one_more_nested() # 40 ХВИЛИНА !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    inner_function() # якщо цього б тут не було - ф-ція one_more_nested не спрацювала б далі

# Global (глобальні): Змінні, оголошені на рівні програми, поза функціями. Доступні на всіх рівня в усьому коді
global_variable = 20

def example_function():
    print(global_variable)  # Глобальна змінна

# Built-in (вбудовані): Це вбудовані імена та функції, такі як print або len. Вони завжди доступні
print(len("Hello, world!"))  # Вбудована функція
# Загальний приклад:
global_variable = 10

def outer_function():
    outer_variable = 5

    def inner_function():
        inner_variable = 3
        print(inner_variable)  # Local (локальна)
        print(outer_variable)  # Enclosing (обхоплююча)
        print(global_variable) # Global (глобальна)

    inner_function()

outer_function()
# inner_function може отримати доступ до своїх локальних змінних (inner_variable), змінних у зовнішній функції outer_function (outer_variable)
# Також до глобальної змінної (global_variable), але не може отримати доступ до локальних змінних зовнішньої функції
print()

# Використання іменованих параметрів.
# Використання іменованих параметрів дозволяє передавати аргументи у функцію, вказуючи їхні імена, що полегшує читання та розуміння коду
# Це особливо корисно при використанні функцій з великою кількістю параметрів, де порядок може бути важливим
def example_function(param1, param2, param3):
    print(param1, param2, param3) # param - параметри

# Без іменованих параметрів - порядок важливий
example_function(1, 2, 3)

# З іменованими параметрами - порядок не важливий
example_function(param1=1, param3=3, param2=2)

# !!! Основні переваги використання іменованих параметрів:
# Читабельність коду: Коли ви вказуєте імена параметрів, код стає більш зрозумілим для вас і інших програмістів
# Універсальність: Ви можете передавати аргументи в будь-якому порядку, незалежно від їхнього положення у визначенні функції
# Зменшення ризику помилок: Імена параметрів слугують "документацією" для того, хто читає або використовує функцію, допомагаючи уникнути неправильного порядку аргументів
# Використання іменованих параметрів може бути особливо корисним при роботі з функціями, які мають багато параметрів чи коли значення деяких параметрів може бути за замовчуванням
print()

# Функції за замовчуванням.
# Функції за замовчуванням дозволяють встановлювати значення за замовчуванням для параметрів функції
# Це означає, що якщо аргумент не передається при виклику функції, буде використовуватися значення за замовчуванням
def example_function(param1, param2=2, param3=3):
    print(param1, param2, param3)

# Виклик без вказання параметрів за замовчуванням
example_function(1)  # Використовуються значення за замовчуванням для param2 і param3

# Зміна значення одного з параметрів
example_function(1, param3=4)  # Вказуємо значення для param3, інші залишаються за замовчуванням

# !!! Основні переваги використання функцій за замовчуванням:
# Гнучкість виклику функції: Ви можете викликати функцію з різною кількістю аргументів, і ті, що не вказані, будуть використовувати значення за замовчуванням
# Читабельність коду: Коли значення параметрів вже вказані визначенням функції, код стає більш зрозумілим
# Зменшення кількості потенційних помилок: Використання функцій за замовчуванням допомагає уникнути неправильного порядку або пропуску деяких параметрів
# Зазначення параметрів за замовчуванням особливо корисно при роботі з функціями, де деякі параметри мають типові значення або їх часто використовують з однаковими значеннями
print()

# Використання змінної кількості аргументів.
# В Python можна використовувати *args у визначенні функції для прийняття змінної кількості позиційних аргументів
# !!! Знак * перед ім'ям аргументу дозволяє функції приймати будь-яку кількість позиційних аргументів і обробляти їх у вигляді кортежу
# Позиційні аргументи — це аргументи, які передаються функції в порядку їх визначення під час виклику, де порядок значення має вирішальне значення
def example_function(*args):
    for arg in args:
        print(arg)

# Виклик функції з різною кількістю позиційних аргументів
example_function(1, 2, 3, 4, 5)

def fruit_set(*args):
    for fruit in args:
        print(fruit)

fruit_set("apple", "banana", "orange")

# !!! Основні особливості використання *args:
# Прийняття будь-якої кількості аргументів: Функція може бути викликана з будь-якою кількістю позиційних аргументів, і всі вони будуть зібрані в кортеж args
# Зручність при роботі з різними об'єктами: args робить функцію більш гнучкою, оскільки ви можете передати будь-яку кількість аргументів, і функція буде працювати з ними
# Необов'язковість вказання кількості аргументів при визначенні функції: Ви не повинні визначати точну кількість аргументів у визначенні функції, що робить її більш адаптивною
# Важливо враховувати, що *args може бути використано лише для позиційних аргументів
# Для іменованих аргументів, що можуть бути передані у функцію, використовується **kwargs
print()

# Використання змінної кількості іменованих аргументів
# !!! У Python можна використовувати **kwargs у визначенні функції для прийняття будь-якої кількості іменованих аргументів у вигляді словника
#  Знак ** перед ім'ям аргументу дозволяє функції приймати будь-яку кількість іменованих аргументів та обробляти їх у вигляді словника
def example_function(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

# Виклик функції з різною кількістю іменованих аргументів
example_function(param1=1, param2=2, param3=3)

def fruit_set(**kwargs):
    for fruit, price in kwargs.items():
        print(f"fruit: {fruit}, price: {price}")

fruit_set(apple=10, banana=20, orange=30, cherry=40)

# !!! Основні особливості використання **kwargs:
# Передача будь-якої кількості іменованих аргументів: Функція може бути викликана з будь-якою кількістю іменованих аргументів, і всі вони будуть зібрані в словник kwargs
# Зручність при роботі з великою кількістю параметрів: *kwargs дозволяє передавати та обробляти велику кількість іменованих аргументів без необхідності визначення кожного окремо в параметрах функції
# Необов'язковість вказання кількості іменованих аргументів при визначенні функції: Ви не повинні визначати точну кількість іменованих аргументів у визначенні функції, що робить її більш адаптивною
# Зручність при взаємодії з іншими функціями та бібліотеками, які використовують іменовані параметри: *kwargs дозволяє передавати всі іменовані аргументи без змін у вигляді словника, що полегшує взаємодію з іншими функціями та бібліотеками
print()

# Тонкощі використання аргументів.
# При виклику та визначенні функцій у Python є деякі тонкощі та порядок, які слід дотримуватися для коректного виконання коду
# Основний порядок подачі аргументів при виклику функції виглядає наступним чином (що передається при ф-ції):
# 1. Будь-які позиційні аргументи (значення)
# 2. Іменовані аргументи (name=value)
# 3. Аргументи у формі sequence (args)
# 4. Аргументи у формі *dict (*kwargs)
# При описі функції порядок подачі аргументів також є важливим:
# 1. Будь-які позиційні аргументи (name)
# 2. Аргументи зі значеннями за замовчанням (name=value)
# 3. Аргументи у формі args
# 4. Будь-які імена або пари name аргументів, які передаються лише на ім'я
# 5. Аргументи у формі *kwargs
# Важливо дотримуватися цього порядку для правильного виклику та визначення функцій
# Порушення цих правил може призвести до помилок виконання або неправильного результату

# Приведемо приклади для кращого розуміння:
def example_function(positional_arg: int, *args, **kwargs): # positional_arg: str - ми говоримо, що це - тип данних str
    print("Positional Arg:", positional_arg)
    print("Additional Positional Args:", args)
    print("Additional Named Args:", kwargs)

# def example_function_with_named_arg(named_arg):
#    print("Named Arg:", named_arg)

# Виклик функції з використанням різних видів аргументів
# example_function(1, *range(3, 6), keyword_arg="value")

# Виклик функції з використанням іменованих аргументів
# example_function_with_named_arg(named_arg=2)
example_function(1, 3, 4, 5, named_arg=2, keyword_arg="value")
# В даному прикладі, позиційні аргументи подаються спочатку, після чого ідуть іменовані аргументи, аргументи у формі *args та **kwargs
print()

# Розпакування кортежу в низку фактичних параметрів.
# Іноді виникає ситуація, коли корисно мати функції, які приймають довільну кількість аргументів
# Використання кортежів для передачі цих аргументів може бути ефективним
# !!! Розпакування кортежу в низку фактичних параметрів дає можливість передати елементи кортежу як окремі аргументи
def example_function(arg1, arg2, arg3):
    print(arg1, arg2, arg3)

example_tuple = (1, 2, 3)
example_function(arg1=example_tuple[0], arg2=example_tuple[1], arg3=example_tuple[2])
example_function(*example_tuple)
# У цьому прикладі *example_tuple вказує Python розпакувати кортеж example_tuple і передати його елементи як аргументи функції
# Функція example_function приймає три аргументи, тому кортеж повинен мати три елементи. Це важливо для уникнення помилок
# Використання розпакування кортежу дозволяє гнучко передавати аргументи в функцію і може бути корисним в ситуаціях, де кількість аргументів може варіюватися
print()

# Розпакування словника в низку фактичних параметрів.
# !!! Подібно до розпакування кортежу, можна використовувати розпакування словника для передачі іменованих аргументів до функції
def example_function(arg1, arg2, arg3):
    print(arg1, arg2, arg3)

example_tuple = {'arg1': 1, 'arg2': 2, 'arg3': 3}
example_function(**example_tuple)
# У цьому випадку **example_tuple вказує Python розпакувати словник example_tuple і передати його ключі та значення як іменовані аргументи функції
# Знову ж таки, функція повинна мати відповідну кількість іменованих параметрів
# Використання розпакування словника дозволяє передавати змінну кількість іменованих аргументів в функцію, що може бути зручним при роботі з функціями, які підтримують різні параметри
print()

# Особливості використання функцій.
# При використанні функцій важливо розуміти, які типи аргументів функції можна передати, і як саме вони обробляються
# Важливо враховувати, чи функція очікує позиційні аргументи, іменовані аргументи, або можливість використовувати обидва типи
def example_function(arg1, *args, arg2=2, **kwargs):
    print(arg1)
    print(args)
    print(arg2)
    print(kwargs)

example_function(1, 3, 5, arg2=4, arg3=6, arg4=8)
# У цьому прикладі функція example_function приймає позиційний аргумент arg1, будь-яку кількість позиційних аргументів *args
# Іменований аргумент за замовчуванням arg2, і будь-яку кількість іменованих аргументів \kwargs
# Такий підхід дозволяє створювати більш гнучкі та універсальні функції
#
# !!! Основні особливості використання функцій включають в себе:F
# Позиційні аргументи: Передаються у порядку, в якому вони вказані у виклику функції.
# Аргументи за замовчуванням: Функції можуть мати аргументи, які мають значення за замовчуванням. Це дозволяє викликати функцію із заздалегідь визначеними значеннями, якщо користувач не вказав інші.
# Змінна кількість аргументів: Використання args дозволяє передавати будь-яку кількість позиційних аргументів.
# Змінна кількість іменованих аргументів: Використання *kwargs дозволяє передавати будь-яку кількість іменованих аргументів у вигляді словника.
# Правило LEGB: Порядок, в якому функція шукає змінні, визначається LEGB (Local, Enclosing, Global, Built-in).