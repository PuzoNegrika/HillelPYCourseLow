# Функція як параметр для іншої функції
# Функції в Python є об'єктами першого класу, що дозволяє передавати їх як аргументи іншим функціям
# У прикладі нижче, функція apply_operation приймає функцію та список даних, застосовує цю функцію до кожного елемента списку та повертає результат.
# У програмуванні функції вважаються об'єктами першого класу, що робить їх такими ж сутностями, як і числа, рядки або списки, тобто:
# 1. Передавати як аргументи іншим функціям
# 2. Призначати їх змінним
# 3. Повертати їх як значення з інших функцій
#
# Це дозволяє створювати більш загальні, абстрактні та гнучкі програми
# Один із широко вживаних підходів - це передача функції як параметра для іншої функції

# Приклад: Застосування Функції до Кожного Елемента Списку
# Розглянемо функцію apply_operation, яка приймає функцію operation та список даних
# Вона застосовує цю функцію до кожного елемента списку і повертає список результатів
def apply_operation(operation, data):
    """
    Застосовує вказану операцію до кожного елемента списку.

    :param operation: Функція-операція для застосування.
    :param data: Список даних.
    :return: Результат операції для кожного елемента списку.
    """
    result = []
    for item in data:
        result.append(operation(item))
    return result

# Приклад використання
def square(x):
    return x ** 2

def double(x):
    return x * 2

numbers = [1, 2, 3, 4, 5]

squared_numbers = apply_operation(square, numbers)
doubled_numbers = apply_operation(double, numbers)

print(squared_numbers)  # [1, 4, 9, 16, 25]
print(doubled_numbers)   # [2, 4, 6, 8, 10]
print()

# У цьому прикладі функції square та double передаються як параметри до функції apply_operation, яка потім використовує їх для обробки списку чисел
# Це робить код більш гнучким, оскільки ми можемо легко змінювати операції, які застосовуються до кожного елемента списку

# Загальні Переваги Вищого Порядку Функцій:
# 1. Абстракція: Дозволяє відділити логіку операцій від конкретних дій
# 2. Гнучкість: Забезпечує гнучкість у визначенні та зміні функцій
# 3. Повторне Використання: Сприяє використанню функцій в різних контекстах
# 4. Загальна Застосованість: Дозволяє створювати загальні алгоритми, які можна використовувати для різних завдань
# Використання функцій як параметрів є потужним інструментом у програмуванні, який дозволяє створювати більш зрозумілі, адаптовані та перевикористовувані рішення


# Документування функцій
# Документування функцій є важливою частиною створення читабельного та зрозумілого коду в Python
# Для цього використовується спеціальний тип коментарів, відомий як docstrings (документуючі рядки)
# Docstrings знаходяться в верхній частині функції та надають інформацію про її призначення, параметри та повертає значення
#
# Приклад Документування Функції:
def calculate_area(radius):
    """
    Calculate the area of a circle.

    :param radius: The radius of the circle.
    :return: The area of the circle.
    """
    area = 3.14 * radius ** 2
    return area

# Виведення документації функції
print(help(calculate_area))

# У цьому прикладі:
# 1. Docstring розпочинається потрійними подвійними лапками (""")
# 2. В першому рядку docstring надається короткий опис того, що робить функція
# 3. Параметри функції описуються в розділі :param
# 4. Розділ :return пояснює значення, яке повертається функцією

# Використання help():
# Один із способів перегляду docstring - використовувати вбудовану функцію help()
help(calculate_area)
# Це виведе докладну інформацію про функцію, включаючи її docstring

# Важливі Поради щодо Документування Функцій:
# 1. Короткий та Зрозумілий Опис: Забезпечте короткий та зрозумілий опис того, що робить функція
# 2. Опис Параметрів: Детально опишіть параметри функції, вказавши їхнє призначення та тип
# 3. Опис Повертаного Значення: Поясніть, що повертається функцією. Якщо функція нічого не повертає, це також варто зазначити
# 4. Розташування: Розміщуйте docstring відразу після заголовку функції, перед тілом функції
# 5. Використовуйте Розмітку ReStructuredText: Хоча ви можете використовувати звичайний текст, рекомендується використовувати розмітку ReStructuredText для більшої гнучкості та підтримки інструментів документації

# Приклад з Використанням Розмітки ReStructuredText:
def calculate_area(length, width):
    """
    Calculate the area of a rectangle.

    :param length: The length of the rectangle.
    :type length: float or int
    :param width: The width of the rectangle.
    :type width: float or int
    :return: The area of the rectangle.
    :rtype: float or int
    """
    area = length * width
    return area

print()
# Такий підхід дозволяє створювати якісну документацію, яка може бути використана для розробки, тестування та розуміння вашого коду іншими користувачами або розробниками


# Анотування типів у функціях
# Анотації типів в Python - це можливість вказати очікувані типи для параметрів та значень, які повертає функція
# Це не обов'язковий елемент мови, але він додає читабельність коду та відкриває можливості для автоматичної перевірки типів

# Синтаксис Анотацій Типів:
# Анотації типів вказуються після імені параметра чи після двокрапки у зворотному відношенні
# Анотації типів не є обов'язковими в Python, але дозволяють вказати очікувані типи для параметрів та значень, що повертає функція
# Це робить код більш зрозумілим та сприяє автоматичній перевірці типів за допомогою інструментів, таких як mypy
def add_numbers(x: int, y: int) -> int:
    return x + y
# У цьому прикладі:
# 1. x: int та y: int - це анотації типів для параметрів x та y
# 2. -> int - це анотація типу для значення, що повертається функцією

# Переваги Анотацій Типів:
# Зрозумілість: Анотації типів роблять код більш зрозумілим, оскільки інші розробники можуть швидше розібратися у типах даних, що обробляються функцією
# Автоматична Перевірка Типів: Деякі інструменти, такі як mypy, можуть використовувати анотації типів для автоматичної перевірки типів коду, що може виявити помилки перед виконанням програми
# Документація: Анотації типів можуть слугувати як частина документації коду, вказуючи, які типи очікуються функцією
#
# Приклад:
def calculate_area(length: float, width: float) -> float:
    """
    Calculate the area of a rectangle.

    :param length: The length of the rectangle.
    :param width: The width of the rectangle.
    :return: The area of the rectangle.
    """
    area = length * width
    return area

# Анотації Типів та Значення за Замовчуванням:
def greet(name: str = "Guest") -> str:
    """
    Greet a person by name.

    :param name: The name of the person (default is "Guest").
    :return: The greeting message.
    """
    return f"Hello, {name}!"

print()
# У цьому прикладі параметр name анотований як str, а значення за замовчуванням - це рядок "Guest"

# Використання інструменту mypy:
# !!! Для автоматичної перевірки типів можна використовувати інструмент mypy
# !!! Це інструмент, який аналізує код і виводить повідомлення про можливі помилки в типах

# Встановлення mypy:
# pip install mypy

# Використання mypy для Перевірки Типів:
# mypy your_script.py

# Це дозволить виявляти помилки типів та надає інформацію про типи, використовувані у вашому коді
# Використання анотацій типів та інструменту mypy робить код більш надійним та допомагає виявляти помилки на етапі розробки

# Рекурсія.
# Що таке Рекурсія?
# !!! Рекурсія - це структура програми, в якій функція викликає сама себе, або через інші функції
# !!! Рекурсивні функції мають два основні компоненти: базовий випадок і рекурсивний виклик

# Приклад: Обчислення Факторіалу
# Рекурсія добре демонструється на прикладі обчислення факторіалу числа
# Факторіал числа n (позначається як n!) - це добуток всіх цілих чисел від 1 до n
def factorial(n):
    """
    Обчислює факторіал числа n.

    :param n: Ціле число.
    :return: Факторіал числа n.
    """
    # Базовий випадок: 0! та 1! рівні 1
    if n == 0 or n == 1:
        return 1
    else:
        # Рекурсивний виклик: n! = n * (n-1)!
        return n * factorial(n - 1)
# Пояснення Коду:
# Базовий випадок: Базовий випадок визначає, коли рекурсія повинна завершитися. У випадку факторіалу, базові випадки - це 0! і 1!, які обидва рівні 1. Це запобігає нескінченному виклику функції
# Рекурсивний виклик: У рекурсивному виклику функція викликає сама себе, скорочуючи задачу до меншого випадку. У випадку факторіалу, n! обчислюється як n помножити на (n-1)!
result = factorial(5)
print(result)  # Результат: 120
print()
# У цьому прикладі, factorial(5) викликає функцію factorial з аргументом 5
# Функція викликає сама себе з аргументом 4, потім 3, 2, 1, і, нарешті, базовий випадок для 0 та 1
# Рекурсивні виклики розгортаються, і результуючий факторіал обчислюється як 5 * 4 * 3 * 2 * 1 = 120

# Переваги та Недоліки Рекурсії:
#
# Переваги:
# 1. Рекурсія може зробити код більш зрозумілим для певних завдань.
# 2. Деякі алгоритми природно використовують рекурсію.
#
# Недоліки:
# 1. Рекурсивні виклики можуть призводити до переповнення стеку при великих значеннях.
# 2. Для деяких людей рекурсія може бути важкою для розуміння.
# Стек у програмуванні — це структура даних, яка працює за принципом LIFO (англ. "last in, first out" – "останнім увійшов, першим вийшов"). Це означає, що елементи додаються і видаляються з вершини стека. Найпопулярнішим прикладом є стопка тарілок або книжок, де новий елемент кладеться зверху, а дістати можна лише верхній.
#
# Основні операції в стеці:
# Push: додати новий елемент на вершину стека
# Pop: видалити та повернути елемент з вершини стека
# Top/Peek: переглянути елемент на вершині, не видаляючи

# Використання рекурсії важливо взважити залежно від конкретної задачі та структури даних
# Завдання, які легко виражаються рекурсією, можуть бути більш читабельними та елегантними за рахунок рекурсивних розв'язків

# Анонімні функції lambda.
# !!! Lambda-функції є короткими, анонімними функціями, які можуть бути оголошені без використання ключового слова def
# !!! Вони часто використовуються для створення невеликих, одноразових функцій
#
# Основні особливості lambda-функцій:
# Анонімність: Lambda-функції є анонімними, що означає, що вони не мають імені, і вони можуть бути визначені та використані в тому ж виразі
# Один Вираз: Lambda-функції можуть містити лише один вираз

# Синтаксис Lambda-функцій:
lambda arguments: expression
# 1. lambda: Ключове слово для вказання, що це lambda-функція
# 2. arguments: Параметри (аргументи) функції
# 3. expression: Вираз, який виконується при виклику функції

# Приклади Використання Lambda-функцій
# Проста Lambda-функція:
square = lambda x: x**2
print(square(5))  # Вивід: 25

# Використання у Створенні Списку:
squared_numbers = [(lambda x: x**2)(x) for x in range(1, 6)]
print(squared_numbers)  # Вивід: [1, 4, 9, 16, 25]

# Використання в Умовному Виразі:
check_even = lambda x: True if x % 2 == 0 else False
print(check_even(4))  # Вивід: True
print(check_even(7))  # Вивід: False
print()

# Переваги і мінуси:
#
# Переваги та Застосування Lambda-функцій:
# 1. Короткий Синтаксис: Lambda-функції дозволяють визначати короткі функції в один рядок
# 2. Використання при Замиканні: Вони часто використовуються при замиканні (closure) для передачі функції як аргументу іншій функції
# 3. Використання у Виразах зі Змінним Кількістю Аргументів: Лямбда-функції можуть приймати різну кількість аргументів
#
# Обмеження Lambda-функцій:
# Один Вираз: Вони обмежені виразами та не можуть містити складнішу логіку
# Важко Читати для Складних Функцій: Для складних функцій, особливо якщо код стає довшим, важко забезпечити хорошу читабельність

# Хоча lambda-функції не є необхідним інструментом в багатьох випадках, вони можуть бути корисними для коротких функцій, які використовуються в обмежених контекстах

# map, filter, zip.
# Ці вирази розширюють можливості обробки даних в Python
# map - застосовує функцію до кожного елемента колекції
# filter - відфільтровує елементи за заданою умовою
# zip - комбінує елементи з кількох колекцій у кортежі

# map - Відображення Елементів
# !!! Функція map використовується для застосування функції до кожного елемента в колекції (наприклад, списку) і повертає новий ітератор з результатами
#
# Приклад: Застосування квадратного кореня до кожного елемента списку
numbers = [1, 2, 3, 4, 5]
squared_root = map(lambda x: x**0.5, numbers)
result = list(squared_root)
print(result)  # Вивід: [1.0, 1.414, 1.732, 2.0, 2.236], кожне число возведемо в степінь 0.05

# filter - Фільтрація Елементів
# !!! Функція filter фільтрує елементи колекції відповідно до заданої умови (функції) і повертає новий ітератор, що містить лише ті елементи, які задовольняють умову
#
# Приклад: Відфільтрувати парні числа
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
result = list(even_numbers)
print(result)  # Вивід: [2, 4, 6, 8, 10], тільки парні числа

# zip - Комбінація Елементів
# !!! Функція zip комбінує елементи з кількох колекцій у кортежі. Вона повертає ітератор, який генерує кортежі, об'єднуючи елементи з відповідних позицій
#
# Приклад: Зіпувати два списки
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 22]
zipped_data = zip(names, ages)
result = list(zipped_data)
print(result)
# Вивід: [('Alice', 25), ('Bob', 30), ('Charlie', 22)]

# Застосування в Об'єднанні map, filter, та zip
# Ці функції можна комбінувати для більш складної обробки даних. Наприклад, використовуючи map та filter разом:
# Приклад: Застосувати функцію до парних чисел
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers))
final_result = list(result)
print(final_result)  # Вивід: [4, 16, 36, 64, 100], возводимо в квадрат тільки парні числа
print()
# Це дозволяє використовувати об'єкти map та filter для обробки даних, що вже використовуються в zip

# Загальні Поради:
# 1. Використовуйте map та filter для чистого та компактного коду при обробці списків та інших колекцій
# 2. zip особливо корисний при об'єднанні даних з різних джерел
# 3. За необхідності, можна використовувати ці функції разом для складніших операцій над даними

# Функції генератори yield.
# !!! Генератори в Python - це спеціальний тип функцій, які використовують ключове слово yield для створення ітераторів
# !!!  Вони дозволяють вам ліниво генерувати послідовності значень без необхідності зберігання всіх значень у пам'яті, що може бути дуже ефективно для обробки великих об'ємів даних
# Ітерація - це процес послідовного проходження по елементах колекції (наприклад, списку, рядка, словника) за допомогою циклів, найчастіше for

# Оголошення Функції-Генератора:
def my_generator():
    yield 1
    yield 2
    yield 3

# Виклик Функції-Генератора та Отримання Значень:
gen = my_generator()

print(next(gen))  # Вивід: 1
print(next(gen))  # Вивід: 2
print(next(gen))  # Вивід: 3

# Використання Генераторів в Циклах:
for value in my_generator():
    print(value)
# Вивід:
# 1
# 2
# 3

# Особливості Функцій-Генераторів:
# Лінивість: Генератори генерують значення ліниво, тобто лише при кожному виклику next() або при ітерації через цикл
# Стан Зберігається: Функції-генератори запам'ятовують свій стан між викликами, що дозволяє їм призупинятися та продовжувати виконання
# Єдина Точка Входу: Функції-генератори мають лише одну точку входу та можуть виробляти послідовності значень одне за одним

# Приклад: Генератор Фібоначчі
def fibonacci_generator(n):
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

# Виклик генератора Фібоначчі
fibonacci = fibonacci_generator(5)
for value in fibonacci:
    print(value)
# Вивід: 0, 1, 1, 2, 3
# У цьому прикладі, генератор fibonacci_generator видає перші n чисел Фібоначчі при кожному виклику next() або при ітерації через цикл

# Використання Генераторів в Проектах:
# Ефективна Обробка Великих Даних: Генератори дозволяють ефективно обробляти великі об'єми даних, так як вони працюють ліниво та зберігають невелику кількість даних у пам'яті
# Створення Ітераторів: Генератори можна використовувати для створення власних ітераторів, що полегшує роботу з ітерацією
# Асинхронні Операції: Генератори також можуть бути використані для асинхронних операцій в Python за допомогою ключового слова async і асинхронних функцій-генераторів

# Функції-генератори є потужним інструментом для оптимізації обробки даних та вирішення завдань, які вимагають обчислень з послідовностями значень